#![feature(prelude_import)]
//! SAP Scripting for Rust
//!
//! See the examples for how to use this library.
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use windows::Win32::System::Com::*;
/// The types from this library.
pub mod types {
    use com_shim::{com_shim, IDispatchExt};
    use windows::{core::*, Win32::System::Com::*, Win32::System::Variant::*};
    /// A wrapper over the SAP scripting engine, equivalent to CSapROTWrapper.
    pub struct SAPWrapper {
        inner: IDispatch,
    }
    impl SAPWrapper {
        pub(crate) fn new() -> crate::Result<Self> {
            unsafe {
                let clsid: GUID = CLSIDFromProgID({
                    const INPUT: &[u8] = "SapROTWr.SapROTWrapper".as_bytes();
                    const OUTPUT_LEN: usize = ::windows_core::utf16_len(INPUT) + 1;
                    const OUTPUT: &[u16; OUTPUT_LEN] = {
                        let mut buffer = [0; OUTPUT_LEN];
                        let mut input_pos = 0;
                        let mut output_pos = 0;
                        while let Some((mut code_point, new_pos)) = ::windows_core::decode_utf8_char(
                            INPUT,
                            input_pos,
                        ) {
                            input_pos = new_pos;
                            if code_point <= 0xffff {
                                buffer[output_pos] = code_point as u16;
                                output_pos += 1;
                            } else {
                                code_point -= 0x10000;
                                buffer[output_pos] = 0xd800 + (code_point >> 10) as u16;
                                output_pos += 1;
                                buffer[output_pos] = 0xdc00 + (code_point & 0x3ff) as u16;
                                output_pos += 1;
                            }
                        }
                        &{ buffer }
                    };
                    ::windows_core::PCWSTR::from_raw(OUTPUT.as_ptr())
                })?;
                let p_clsid: *const GUID = &clsid;
                {
                    let lvl = ::log::Level::Debug;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!("CSapROTWrapper CLSID: {0:?}", clsid),
                            lvl,
                            &(
                                "sap_scripting::types",
                                "sap_scripting::types",
                                "src/types.rs",
                            ),
                            14u32,
                            ::log::__private_api::Option::None,
                        );
                    }
                };
                let dispatch: IDispatch = CoCreateInstance(
                    p_clsid,
                    None,
                    CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER,
                )?;
                Ok(SAPWrapper { inner: dispatch })
            }
        }
        /// Get the Scripting Engine object from this wrapper.
        pub fn scripting_engine(&self) -> crate::Result<GuiApplication> {
            {
                let lvl = ::log::Level::Debug;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        format_args!("Getting UI ROT entry..."),
                        lvl,
                        &(
                            "sap_scripting::types",
                            "sap_scripting::types",
                            "src/types.rs",
                        ),
                        24u32,
                        ::log::__private_api::Option::None,
                    );
                }
            };
            let result = self
                .inner
                .call(
                    "GetROTEntry",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([VARIANT::from_str("SAPGUI")]),
                    ),
                )?;
            let sap_gui = result.to_idispatch()?;
            {
                let lvl = ::log::Level::Debug;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        format_args!("Getting scripting engine."),
                        lvl,
                        &(
                            "sap_scripting::types",
                            "sap_scripting::types",
                            "src/types.rs",
                        ),
                        31u32,
                        ::log::__private_api::Option::None,
                    );
                }
            };
            let scripting_engine = sap_gui
                .call("GetScriptingEngine", ::alloc::vec::Vec::new())?;
            Ok(GuiApplication {
                inner: scripting_engine.to_idispatch()?.clone(),
            })
        }
    }
    /// SAPComponent wraps around all of the GuiComponent types, allowing a more Rust-y way of exporing components.
    pub enum SAPComponent {
        /// The GuiApplication represents the process in which all SAP GUI activity takes place. If the scripting
        /// component is accessed by attaching to an SAP Logon process, then GuiApplication will represent SAP
        /// Logon. GuiApplication is a creatable class. However, there must be only one component of this type
        /// in any process. GuiApplication extends the GuiContainer Object.
        GuiApplication(GuiApplication),
        /// The GuiBarChart is a powerful tool to display and modify time scale diagrams.
        GuiBarChart(GuiBarChart),
        /// A GuiBox is a simple frame with a name (also called a "Group Box"). The items inside the frame are not
        /// children of the box. The type prefix is "box".
        GuiBox(GuiBox),
        /// GuiButton represents all push buttons that are on dynpros, the toolbar or in table controls. GuiButton
        /// extends the GuiVComponent Object. The type prefix is btn, the name property is the fieldname taken
        /// from the SAP data dictionary There is one exception: For tabstrip buttons, it is the button id set in
        /// screen painter that is taken from the SAP data dictionary.
        GuiButton(GuiButton),
        /// The calendar control can be used to select single dates or periods of time. GuiCalendar extends the
        /// GuiShell Object.
        GuiCalendar(GuiCalendar),
        /// The GuiChart object is of a very technical nature. It should only be used for recording and playback, as
        /// most of the parameters cannot be determined in any other way.
        GuiChart(GuiChart),
        /// GuiCheckBox extends the GuiVComponent Object. The type prefix is chk, the name is the fieldname taken
        /// from the SAP data dictionary.
        GuiCheckBox(GuiCheckBox),
        /// GuiColorSelector displays a set of colors for selection. It extends the GuiShell Object.
        GuiColorSelector(GuiColorSelector),
        /// The GuiComboBox looks somewhat similar to GuiCTextField, but has a completely different implementation.
        /// While pressing the combo box button of a GuiCTextField will open a new dynpro or control in which a
        /// selection can be made, GuiComboBox retrieves all possible choices on initialization from the server, so
        /// the selection is done solely on the client. GuiComboBox extends the GuiVComponent Object. The type prefix
        /// is cmb, the name is the fieldname taken from the SAP data dictionary. GuiComboBox inherits from the
        /// GuiVComponent Object.
        GuiComboBox(GuiComboBox),
        ///
        GuiComboBoxControl(GuiComboBoxControl),
        /// Members of the Entries collection of a GuiComboBox are of type GuiComBoxEntry.
        GuiComboBoxEntry(GuiComboBoxEntry),
        /// GuiComponent is the base class for most classes in the Scripting API. It was designed to allow generic
        /// programming, meaning you can work with objects without knowing their exact type.
        GuiComponent(GuiComponent),
        /// A GuiConnection represents the connection between SAP GUI and an application server. Connections can be opened
        /// from SAP Logon or from GuiApplication’s openConnection and openConnectionByConnectionString methods.
        /// GuiConnection extends the GuiContainer Object. The type prefix for GuiConnection is con, the name is con
        /// plus the connection number in square brackets.
        GuiConnection(GuiConnection),
        /// This interface resembles GuiVContainer. The only difference is that it is not intended for visual objects
        /// but rather administrative objects such as connections or sessions. Objects exposing this interface will
        /// therefore support GuiComponent but not GuiVComponent. GuiContainer extends the GuiComponent Object.
        GuiContainer(GuiContainer),
        /// A GuiContainerShell is a wrapper for a set of the GuiShell Object. GuiContainerShell extends the GuiVContainer
        /// Object. The type prefix is shellcont, the name is the last part of the id, shellcont\[n\].
        GuiContainerShell(GuiContainerShell),
        /// If the cursor is set into a text field of type GuiCTextField a combo box button is displayed to the right of
        /// the text field. Pressing this button is equivalent to pressing the F4 key. The button is not represented in
        /// the scripting object model as a separate object; it is considered to be part of the text field.
        ///
        /// There are no other differences between GuiTextField and GuiCTextField. GuiCTextField extends the GuiTextField.
        /// The type prefix is ctxt, the name is the Fieldname taken from the SAP data dictionary.
        GuiCTextField(GuiCTextField),
        /// The GuiCustomControl is a wrapper object that is used to place ActiveX controls onto dynpro screens. While
        /// GuiCustomControl is a dynpro element itself, its children are of GuiContainerShell type, which is a container
        /// for controls. GuiCustomControl extends the GuiVContainer Object. The type prefix is cntl, the name is the
        /// fieldname taken from the SAP data dictionary.
        GuiCustomControl(GuiCustomControl),
        /// The GuiDialogShell is an external window that is used as a container for other shells, for example a toolbar.
        /// GuiDialogShell extends the GuiVContainer Object. The type prefix is shellcont, the name is the last part of
        /// the id, shellcont\[n\].
        GuiDialogShell(GuiDialogShell),
        /// The GuiEAIViewer2D control is used to view 2-dimensional graphic images in the SAP system. The user can carry
        /// out redlining over the loaded image. The scripting wrapper for this control records all user actions during
        /// the redlining process and reproduces the same actions when the recorded script is replayed.
        GuiEAIViewer2D(GuiEAIViewer2D),
        /// The GuiEAIViewer3D control is used to view 3-dimensional graphic images in the SAP system.
        GuiEAIViewer3D(GuiEAIViewer3D),
        /// A GuiFrameWindow is a high level visual object in the runtime hierarchy. It can be either the main window or
        /// a modal popup window. See the GuiMainWindow and GuiModalWindow sections for examples. GuiFrameWindow itself
        /// is an abstract interface. GuiFrameWindow extends the GuiVContainer Object. The type prefix is wnd, the name
        /// is wnd plus the window number in square brackets.
        GuiFrameWindow(GuiFrameWindow),
        /// The GuiGosShell is only available in New Visual Design mode. GuiGOSShell extends the GuiVContainer Object.
        /// The type prefix is shellcont, the name is the last part of the id, shellcont\[n\].
        GuiGOSShell(GuiGOSShell),
        /// For the graphic adapter control only basic members from GuiShell are available. Recording and playback is
        /// not possible.
        GuiGraphAdapt(GuiGraphAdapt),
        /// The grid view is similar to the dynpro table control, but significantly more powerful. GuiGridView extends
        /// the GuiShell Object.
        GuiGridView(GuiGridView),
        /// The GuiHTMLViewer is used to display an HTML document inside SAP GUI. GuiHTMLViewer extends the GuiShell
        /// Object.
        GuiHTMLViewer(GuiHTMLViewer),
        ///
        GuiInputFieldControl(GuiInputFieldControl),
        /// GuiLabel extends the GuiVComponent Object. The type prefix is lbl, the name is the fieldname taken from the
        /// SAP data dictionary.
        GuiLabel(GuiLabel),
        /// This window represents the main window of an SAP GUI session.
        GuiMainWindow(GuiMainWindow),
        /// For the map control only basic members from GuiShell are available. Recording and playback is not possible.
        GuiMap(GuiMap),
        /// A GuiMenu may have other GuiMenu objects as children. GuiMenu extends the GuiVContainer Object. The type prefix
        /// is menu, the name is the text of the menu item. If the item does not have a text, which is the case for
        /// separators, then the name is the last part of the id, menu\[n\].
        GuiMenu(GuiMenu),
        /// Only the main window has a menubar. The children of the menubar are menus. GuiMenubar extends the GuiVContainer
        /// Object. The type prefix and name are mbar.
        GuiMenubar(GuiMenubar),
        /// A GuiModalWindow is a dialog pop-up.
        GuiModalWindow(GuiModalWindow),
        /// The GuiNetChart is a powerful tool to display and modify entity relationship diagrams. It is of a very technical
        /// nature and should only be used for recording and playback, as most of the parameters cannot be determined in
        /// any other way.
        GuiNetChart(GuiNetChart),
        ///
        GuiOfficeIntegration(GuiOfficeIntegration),
        /// The GuiOkCodeField is placed on the upper toolbar of the main window. It is a combo box into which commands can
        /// be entered. Setting the text of GuiOkCodeField will not execute the command until server communication is
        /// started, for example by emulating the Enter key (VKey 0). GuiOkCodeField extends the GuiVComponent Object. The
        /// type prefix is okcd, the name is empty.
        GuiOkCodeField(GuiOkCodeField),
        /// There are some differences between GuiTextField and GuiPasswordField:
        ///
        /// - The Text and DisplayedText properties cannot be read for a password field. The returned text is always empty.
        /// During recording the password is also not saved in the recorded script.
        /// - The properties HistoryCurEntry, HistoryCurIndex, HistoryIsActive and HistoryList are not supported, because
        /// password fields do not offer an input history
        /// - The property IsListElement is not supported, because password fields cannot be placed on ABAP lists
        GuiPasswordField(GuiPasswordField),
        /// The picture control displays a picture on an SAP GUI screen. GuiPicture extends the GuiShell Object.
        GuiPicture(GuiPicture),
        /// GuiRadioButton extends the GuiVComponent Object. The type prefix is rad, the name is the fieldname taken from the
        /// SAP data dictionary.
        GuiRadioButton(GuiRadioButton),
        /// For the SAP chart control only basic members from GuiShell are available. Recording and playback is not possible.
        GuiSapChart(GuiSapChart),
        /// The GuiScrollbar class is a utility class used for example in GuiScrollContainer or GuiTableControl.
        GuiScrollbar(GuiScrollbar),
        /// This container represents scrollable subscreens. A subscreen may be scrollable without actually having a scrollbar,
        /// because the existence of a scrollbar depends on the amount of data displayed and the size of the GuiUserArea.
        /// GuiScrollContainer extend sthe GuiVContainer Object. The type prefix is ssub, the name is generated from the data
        /// dictionary settings.
        GuiScrollContainer(GuiScrollContainer),
        /// GuiSession is self-contained in that ids within the context of a session remain valid independently of other connections
        /// or sessions being open at the same time. Usually an external application will first determine with which session to
        /// interact. Once that is clear, the application will work more or less exclusively on that session. Traversing the object
        /// hierarchy from the GuiApplication to the user interface elements, it is the session among whose children the highest
        /// level visible objects can be found. In contrast to objects like buttons or text fields, the session remains valid until
        /// the corresponding main window has been closed, whereas buttons, for example, are destroyed during each server
        /// communication.
        GuiSession(GuiSession),
        /// GuiShell is an abstract object whose interface is supported by all the controls. GuiShell extends the GuiVContainer
        /// Object. The type prefix is shell, the name is the last part of the id, shell\[n\].
        GuiShell(GuiShell),
        /// This container represents non-scrollable subscreens. It does not have any functionality apart from to the inherited
        /// interfaces. GuiSimpleContainer extends the GuiVContainer Object. The type prefix is sub, the name is is generated
        /// from the data dictionary settings.
        GuiSimpleContainer(GuiSimpleContainer),
        /// GuiSplit extends the GuiShell Object.
        GuiSplit(GuiSplit),
        /// The GuiSplitterContainer represents the dynpro splitter element, which was introduced in the Web Application Server
        /// ABAP in NetWeaver 7.1. The dynpro splitter element is similar to the activeX based splitter control, but it is a
        /// plain dynpro element.
        GuiSplitterContainer(GuiSplitterContainer),
        /// For the stage control only basic members from GuiShell are available. Recording and playback is not possible.
        GuiStage(GuiStage),
        /// GuiStatusbar represents the message displaying part of the status bar on the bottom of the SAP GUI window. It does
        /// not include the system and login information displayed in the rightmost area of the status bar as these are available
        /// from the GuiSessionInfo object. GuiStatusbar extends the GuiVComponent Object. The type prefix is sbar.
        GuiStatusbar(GuiStatusbar),
        /// The parent of the GuiStatusPane objects is the status bar (see also GuiStatusbar Object). The GuiStatusPane objects
        /// reflect the individual areas of the status bar, for example "pane\[0\]" refers to the section of the status bar where
        /// the messages are displayed. See also GuiStatusbar Object. The first pane of the GuiStatusBar (pane\[0\]) can have a
        /// child of type GuiStatusBarLink, if a service request link is displayed.
        GuiStatusPane(GuiStatusPane),
        /// The GuiTab objects are the children of a GuiTabStrip object. GuiTab extends the GuiVContainer Object. The type prefix
        /// is tabp, the name is the id of the tab’s button taken from SAP data dictionary.
        GuiTab(GuiTab),
        /// The table control is a standard dynpro element, in contrast to the GuiCtrlGridView, which looks similar. GuiTableControl
        /// extends the GuiVContainer Object. The type prefix is tbl, the name is the fieldname taken from the SAP data dictionary.
        GuiTableControl(GuiTableControl),
        /// A tab strip is a container whose children are of type GuiTab. GuiTabStrip extends the GuiVContainer Object. The type
        /// prefix is tabs, the name is the fieldname taken from the SAP data dictionary.
        GuiTabStrip(GuiTabStrip),
        /// The TextEdit control is a multiline edit control offering a number of possible benefits. With regard to scripting,
        /// the possibility of protecting text parts against editing by the user is especially useful. GuiTextedit extends the
        /// GuiShell Object.
        GuiTextedit(GuiTextedit),
        /// GuiTextField extends the GuiVComponent Object. The type prefix is txt, the name is the fieldname taken from the
        /// SAP data dictionary.
        GuiTextField(GuiTextField),
        /// The titlebar is only displayed and exposed as a separate object in New Visual Design mode. GuiTitlebar extends the
        /// GuiVContainer Object. The type prefix and name of GuiTitlebar are titl.
        GuiTitlebar(GuiTitlebar),
        /// Every GuiFrameWindow has a GuiToolbar. The GuiMainWindow has two toolbars unless the second has been turned off by
        /// the ABAP application. In classical SAP GUI themes, the upper toolbar is called “system toolbar” or “GUI toolbar” ,
        /// while the second toolbar is called “application toolbar”. In SAP GUI themes as of Belize and in integration scenarios
        /// (like embedded into SAP Business Client), only a single toolbar (“merged toolbar") is displayed. Additionally, a footer
        /// also containing buttons originally coming from the system or application toolbar may be displayed.
        GuiToolbar(GuiToolbar),
        /// A Tree view.
        GuiTree(GuiTree),
        /// The GuiUserArea comprises the area between the toolbar and status bar for windows of GuiMainWindow type and the area
        /// between the titlebar and toolbar for modal windows, and may also be limited by docker controls. The standard dynpro
        /// elements can be found only in this area, with the exception of buttons, which are also found in the toolbars.
        GuiUserArea(GuiUserArea),
        /// The GuiVComponent interface is exposed by all visual objects, such as windows, buttons or text fields. Like GuiComponent,
        /// it is an abstract interface. Any object supporting the GuiVComponent interface also exposes the GuiComponent interface.
        /// GuiVComponent extends the GuiComponent Object.
        GuiVComponent(GuiVComponent),
        /// An object exposes the GuiVContainer interface if it is both visible and can have children. It will then also expose
        /// GuiComponent and GuiVComponent. Examples of this interface are windows and subscreens, toolbars or controls having
        /// children, such as the splitter control. GuiVContainer extends the GuiContainer Object and the GuiVComponent Object.
        GuiVContainer(GuiVContainer),
        /// GuiVHViewSwitch represents the “View Switch” object that was introduced with the Belize theme in SAP GUI. The View Switch
        /// is placed in the header area of the SAP GUI main window and can be used to select different views within an application.
        /// Many screens can be displayed in different ways (for example, as a tree or list). To switch from one view to another in
        /// a comfortable way, these screens may make use of the View Switch:
        GuiVHViewSwitch(GuiVHViewSwitch),
    }
    impl From<IDispatch> for SAPComponent {
        fn from(value: IDispatch) -> Self {
            let value = GuiComponent { inner: value };
            if let Ok(mut kind) = value._type() {
                {
                    let lvl = ::log::Level::Debug;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!(
                                "Converting component {0} to SAPComponent.",
                                kind,
                            ),
                            lvl,
                            &(
                                "sap_scripting::types",
                                "sap_scripting::types",
                                "src/types.rs",
                            ),
                            266u32,
                            ::log::__private_api::Option::None,
                        );
                    }
                };
                if kind.as_str() == "GuiShell" {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!("Kind is shell, checking subkind."),
                                lvl,
                                &(
                                    "sap_scripting::types",
                                    "sap_scripting::types",
                                    "src/types.rs",
                                ),
                                268u32,
                                ::log::__private_api::Option::None,
                            );
                        }
                    };
                    if let Ok(sub_kind) = (GuiShell {
                        inner: value.inner.clone(),
                    })
                        .sub_type()
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!("Subkind is {0}", sub_kind),
                                    lvl,
                                    &(
                                        "sap_scripting::types",
                                        "sap_scripting::types",
                                        "src/types.rs",
                                    ),
                                    271u32,
                                    ::log::__private_api::Option::None,
                                );
                            }
                        };
                        kind = sub_kind;
                    }
                }
                match kind.as_str() {
                    "GuiApplication" => {
                        SAPComponent::GuiApplication(GuiApplication {
                            inner: value.inner,
                        })
                    }
                    "BarChart" => {
                        SAPComponent::GuiBarChart(GuiBarChart { inner: value.inner })
                    }
                    "GuiBox" => SAPComponent::GuiBox(GuiBox { inner: value.inner }),
                    "GuiButton" => {
                        SAPComponent::GuiButton(GuiButton { inner: value.inner })
                    }
                    "Calendar" => {
                        SAPComponent::GuiCalendar(GuiCalendar { inner: value.inner })
                    }
                    "Chart" => SAPComponent::GuiChart(GuiChart { inner: value.inner }),
                    "GuiCheckBox" => {
                        SAPComponent::GuiCheckBox(GuiCheckBox { inner: value.inner })
                    }
                    "ColorSelector" => {
                        SAPComponent::GuiColorSelector(GuiColorSelector {
                            inner: value.inner,
                        })
                    }
                    "GuiComboBox" => {
                        SAPComponent::GuiComboBox(GuiComboBox { inner: value.inner })
                    }
                    "ComboBoxControl" => {
                        SAPComponent::GuiComboBoxControl(GuiComboBoxControl {
                            inner: value.inner,
                        })
                    }
                    "GuiComboBoxEntry" => {
                        SAPComponent::GuiComboBoxEntry(GuiComboBoxEntry {
                            inner: value.inner,
                        })
                    }
                    "GuiComponent" => SAPComponent::GuiComponent(value),
                    "GuiConnection" => {
                        SAPComponent::GuiConnection(GuiConnection {
                            inner: value.inner,
                        })
                    }
                    "GuiContainer" => {
                        SAPComponent::GuiContainer(GuiContainer { inner: value.inner })
                    }
                    "ContainerShell" => {
                        SAPComponent::GuiContainerShell(GuiContainerShell {
                            inner: value.inner,
                        })
                    }
                    "GuiCTextField" => {
                        SAPComponent::GuiCTextField(GuiCTextField {
                            inner: value.inner,
                        })
                    }
                    "GuiCustomControl" => {
                        SAPComponent::GuiCustomControl(GuiCustomControl {
                            inner: value.inner,
                        })
                    }
                    "GuiDialogShell" => {
                        SAPComponent::GuiDialogShell(GuiDialogShell {
                            inner: value.inner,
                        })
                    }
                    "EAIViewer2D" => {
                        SAPComponent::GuiEAIViewer2D(GuiEAIViewer2D {
                            inner: value.inner,
                        })
                    }
                    "EAIViewer3D" => {
                        SAPComponent::GuiEAIViewer3D(GuiEAIViewer3D {
                            inner: value.inner,
                        })
                    }
                    "GuiFrameWindow" => {
                        SAPComponent::GuiFrameWindow(GuiFrameWindow {
                            inner: value.inner,
                        })
                    }
                    "GuiGOSShell" => {
                        SAPComponent::GuiGOSShell(GuiGOSShell { inner: value.inner })
                    }
                    "GraphAdapt" => {
                        SAPComponent::GuiGraphAdapt(GuiGraphAdapt {
                            inner: value.inner,
                        })
                    }
                    "GridView" => {
                        SAPComponent::GuiGridView(GuiGridView { inner: value.inner })
                    }
                    "HTMLViewer" => {
                        SAPComponent::GuiHTMLViewer(GuiHTMLViewer {
                            inner: value.inner,
                        })
                    }
                    "InputFieldControl" => {
                        SAPComponent::GuiInputFieldControl(GuiInputFieldControl {
                            inner: value.inner,
                        })
                    }
                    "GuiLabel" => SAPComponent::GuiLabel(GuiLabel { inner: value.inner }),
                    "GuiMainWindow" => {
                        SAPComponent::GuiMainWindow(GuiMainWindow {
                            inner: value.inner,
                        })
                    }
                    "Map" => SAPComponent::GuiMap(GuiMap { inner: value.inner }),
                    "GuiMenu" => SAPComponent::GuiMenu(GuiMenu { inner: value.inner }),
                    "GuiMenubar" => {
                        SAPComponent::GuiMenubar(GuiMenubar { inner: value.inner })
                    }
                    "GuiModalWindow" => {
                        SAPComponent::GuiModalWindow(GuiModalWindow {
                            inner: value.inner,
                        })
                    }
                    "NetChart" => {
                        SAPComponent::GuiNetChart(GuiNetChart { inner: value.inner })
                    }
                    "OfficeIntegration" => {
                        SAPComponent::GuiOfficeIntegration(GuiOfficeIntegration {
                            inner: value.inner,
                        })
                    }
                    "GuiOkCodeField" => {
                        SAPComponent::GuiOkCodeField(GuiOkCodeField {
                            inner: value.inner,
                        })
                    }
                    "GuiPasswordField" => {
                        SAPComponent::GuiPasswordField(GuiPasswordField {
                            inner: value.inner,
                        })
                    }
                    "Picture" => {
                        SAPComponent::GuiPicture(GuiPicture { inner: value.inner })
                    }
                    "GuiRadioButton" => {
                        SAPComponent::GuiRadioButton(GuiRadioButton {
                            inner: value.inner,
                        })
                    }
                    "SapChart" => {
                        SAPComponent::GuiSapChart(GuiSapChart { inner: value.inner })
                    }
                    "GuiScrollbar" => {
                        SAPComponent::GuiScrollbar(GuiScrollbar { inner: value.inner })
                    }
                    "GuiScrollContainer" => {
                        SAPComponent::GuiScrollContainer(GuiScrollContainer {
                            inner: value.inner,
                        })
                    }
                    "GuiSession" => {
                        SAPComponent::GuiSession(GuiSession { inner: value.inner })
                    }
                    "GuiShell" => SAPComponent::GuiShell(GuiShell { inner: value.inner }),
                    "GuiSimpleContainer" => {
                        SAPComponent::GuiSimpleContainer(GuiSimpleContainer {
                            inner: value.inner,
                        })
                    }
                    "Split" => SAPComponent::GuiSplit(GuiSplit { inner: value.inner }),
                    "SplitterContainer" => {
                        SAPComponent::GuiSplitterContainer(GuiSplitterContainer {
                            inner: value.inner,
                        })
                    }
                    "Stage" => SAPComponent::GuiStage(GuiStage { inner: value.inner }),
                    "GuiStatusbar" => {
                        SAPComponent::GuiStatusbar(GuiStatusbar { inner: value.inner })
                    }
                    "GuiStatusPane" => {
                        SAPComponent::GuiStatusPane(GuiStatusPane {
                            inner: value.inner,
                        })
                    }
                    "GuiTab" => SAPComponent::GuiTab(GuiTab { inner: value.inner }),
                    "GuiTableControl" => {
                        SAPComponent::GuiTableControl(GuiTableControl {
                            inner: value.inner,
                        })
                    }
                    "GuiTabStrip" => {
                        SAPComponent::GuiTabStrip(GuiTabStrip { inner: value.inner })
                    }
                    "Textedit" => {
                        SAPComponent::GuiTextedit(GuiTextedit { inner: value.inner })
                    }
                    "GuiTextField" => {
                        SAPComponent::GuiTextField(GuiTextField { inner: value.inner })
                    }
                    "GuiTitlebar" => {
                        SAPComponent::GuiTitlebar(GuiTitlebar { inner: value.inner })
                    }
                    "GuiToolbar" => {
                        SAPComponent::GuiToolbar(GuiToolbar { inner: value.inner })
                    }
                    "Tree" => SAPComponent::GuiTree(GuiTree { inner: value.inner }),
                    "GuiUserArea" => {
                        SAPComponent::GuiUserArea(GuiUserArea { inner: value.inner })
                    }
                    "GuiVComponent" => {
                        SAPComponent::GuiVComponent(GuiVComponent {
                            inner: value.inner,
                        })
                    }
                    "GuiVContainer" => {
                        SAPComponent::GuiVContainer(GuiVContainer {
                            inner: value.inner,
                        })
                    }
                    "GuiVHViewSwitch" => {
                        SAPComponent::GuiVHViewSwitch(GuiVHViewSwitch {
                            inner: value.inner,
                        })
                    }
                    _ => SAPComponent::GuiComponent(value),
                }
            } else {
                SAPComponent::GuiComponent(value)
            }
        }
    }
    impl From<VARIANT> for SAPComponent {
        fn from(value: VARIANT) -> Self {
            let idisp = value.to_idispatch().unwrap();
            Self::from(idisp.clone())
        }
    }
    pub struct GuiApplication {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiApplication {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiApplicationExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn allow_system_messages(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("AllowSystemMessages")?.variant_into()?,
            )
        }
        fn set_allow_system_messages(&self, value: bool) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("AllowSystemMessages", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn buttonbar_visible(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ButtonbarVisible")?.variant_into()?,
            )
        }
        fn set_buttonbar_visible(&self, value: bool) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("ButtonbarVisible", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn children(&self) -> ::com_shim::Result<GuiComponentCollection> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Children")?.variant_into()?,
            )
        }
        fn connection_error_text(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ConnectionErrorText")?.variant_into()?,
            )
        }
        fn connections(&self) -> ::com_shim::Result<GuiComponentCollection> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Connections")?.variant_into()?,
            )
        }
        fn history_enabled(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("HistoryEnabled")?.variant_into()?,
            )
        }
        fn set_history_enabled(&self, value: bool) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("HistoryEnabled", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn major_version(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("MajorVersion")?.variant_into()?,
            )
        }
        fn minor_version(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("MinorVersion")?.variant_into()?,
            )
        }
        fn new_visual_design(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("NewVisualDesign")?.variant_into()?,
            )
        }
        fn patchlevel(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Patchlevel")?.variant_into()?,
            )
        }
        fn revision(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Revision")?.variant_into()?,
            )
        }
        fn statusbar_visible(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("StatusbarVisible")?.variant_into()?,
            )
        }
        fn set_statusbar_visible(&self, value: bool) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("StatusbarVisible", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn titlebar_visible(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("TitlebarVisible")?.variant_into()?,
            )
        }
        fn set_titlebar_visible(&self, value: bool) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("TitlebarVisible", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn toolbar_visible(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ToolbarVisible")?.variant_into()?,
            )
        }
        fn set_toolbar_visible(&self, value: bool) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("ToolbarVisible", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn utils(&self) -> ::com_shim::Result<GuiUtils> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Utils")?.variant_into()?)
        }
        fn add_history_entry(&self, p0: String, p1: String) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("AddHistoryEntry", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn create_gui_collection(&self) -> ::com_shim::Result<GuiCollection> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("CreateGuiCollection", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn drop_history(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("DropHistory", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn ignore(&self, p0: i16) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "Ignore",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn open_connection(&self, p0: String) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "OpenConnection",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn open_connection_by_connection_string(
            &self,
            p0: String,
        ) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "OpenConnectionByConnectionString",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
    }
    impl GuiApplicationExt for GuiApplication {}
    impl GuiContainerExt for GuiApplication {}
    impl GuiComponentExt for GuiApplication {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiApplication {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiApplication> for ::com_shim::VARIANT {
        fn variant_from(value: GuiApplication) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiApplication> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiApplication::from(idisp))
        }
    }
    pub struct GuiBarChart {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiBarChart {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiBarChartExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn chart_count(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ChartCount")?.variant_into()?,
            )
        }
        fn bar_count(&self, p0: i32) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "BarCount",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_bar_content(
            &self,
            p0: i32,
            p1: i32,
            p2: i32,
        ) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetBarContent", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_grid_line_content(
            &self,
            p0: i32,
            p1: i32,
            p2: i32,
        ) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetGridLineContent", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn grid_count(&self, p0: i32) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GridCount",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn link_count(&self, p0: i32) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "LinkCount",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn send_data(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "SendData",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiBarChartExt for GuiBarChart {}
    impl GuiVContainerExt for GuiBarChart {}
    impl GuiVComponentExt for GuiBarChart {}
    impl GuiContainerExt for GuiBarChart {}
    impl GuiComponentExt for GuiBarChart {}
    impl GuiShellExt for GuiBarChart {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiBarChart {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiBarChart> for ::com_shim::VARIANT {
        fn variant_from(value: GuiBarChart) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiBarChart> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiBarChart::from(idisp))
        }
    }
    pub struct GuiBox {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiBox {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiBoxExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn char_height(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharHeight")?.variant_into()?,
            )
        }
        fn char_left(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharLeft")?.variant_into()?,
            )
        }
        fn char_top(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharTop")?.variant_into()?,
            )
        }
        fn char_width(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharWidth")?.variant_into()?,
            )
        }
    }
    impl GuiBoxExt for GuiBox {}
    impl GuiVComponentExt for GuiBox {}
    impl GuiComponentExt for GuiBox {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiBox {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiBox> for ::com_shim::VARIANT {
        fn variant_from(value: GuiBox) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiBox> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiBox::from(idisp))
        }
    }
    pub struct GuiButton {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiButton {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiButtonExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn emphasized(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Emphasized")?.variant_into()?,
            )
        }
        fn left_label(&self) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("LeftLabel")?.variant_into()?,
            )
        }
        fn right_label(&self) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("RightLabel")?.variant_into()?,
            )
        }
        fn press(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("Press", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiButtonExt for GuiButton {}
    impl GuiVComponentExt for GuiButton {}
    impl GuiComponentExt for GuiButton {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiButton {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiButton> for ::com_shim::VARIANT {
        fn variant_from(value: GuiButton) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiButton> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiButton::from(idisp))
        }
    }
    pub struct GuiCalendar {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiCalendar {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiCalendarExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn end_selection(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("endSelection")?.variant_into()?,
            )
        }
        fn first_visible_date(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("FirstVisibleDate")?.variant_into()?,
            )
        }
        fn set_first_visible_date(&self, value: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("FirstVisibleDate", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn focus_date(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("FocusDate")?.variant_into()?,
            )
        }
        fn set_focus_date(&self, value: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("FocusDate", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn focused_element(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("FocusedElement")?.variant_into()?,
            )
        }
        fn horizontal(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("horizontal")?.variant_into()?,
            )
        }
        fn last_visible_date(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("LastVisibleDate")?.variant_into()?,
            )
        }
        fn set_last_visible_date(&self, value: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("LastVisibleDate", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn selection_interval(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("SelectionInterval")?.variant_into()?,
            )
        }
        fn set_selection_interval(&self, value: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("SelectionInterval", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn start_selection(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("startSelection")?.variant_into()?,
            )
        }
        fn today(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Today")?.variant_into()?)
        }
        fn context_menu(
            &self,
            p0: i32,
            p1: i32,
            p2: i32,
            p3: String,
            p4: String,
        ) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("ContextMenu", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn create_date(&self, p0: i32, p1: i32, p2: i32) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("CreateDate", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn get_color(&self, p0: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetColor",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_color_info(&self, p0: i32) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetColorInfo",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_date_tooltip(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetDateTooltip",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_day(&self, p0: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetDay",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_month(&self, p0: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetMonth",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_weekday(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetWeekday",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_week_number(&self, p0: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetWeekNumber",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_year(&self, p0: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetYear",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn is_weekend(&self, p0: String) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "IsWeekend",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn select_month(&self, p0: i32, p1: i32) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("SelectMonth", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn select_range(&self, p0: String, p1: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("SelectRange", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn select_week(&self, p0: i32, p1: i32) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("SelectWeek", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiCalendarExt for GuiCalendar {}
    impl GuiVContainerExt for GuiCalendar {}
    impl GuiVComponentExt for GuiCalendar {}
    impl GuiContainerExt for GuiCalendar {}
    impl GuiComponentExt for GuiCalendar {}
    impl GuiShellExt for GuiCalendar {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiCalendar {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiCalendar> for ::com_shim::VARIANT {
        fn variant_from(value: GuiCalendar) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiCalendar> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiCalendar::from(idisp))
        }
    }
    pub struct GuiChart {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiChart {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiChartExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn value_change(
            &self,
            p0: i32,
            p1: i32,
            p2: String,
            p3: String,
            p4: bool,
            p5: String,
            p6: String,
            p7: i32,
        ) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("ValueChange", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiChartExt for GuiChart {}
    impl GuiVContainerExt for GuiChart {}
    impl GuiVComponentExt for GuiChart {}
    impl GuiContainerExt for GuiChart {}
    impl GuiComponentExt for GuiChart {}
    impl GuiShellExt for GuiChart {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiChart {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiChart> for ::com_shim::VARIANT {
        fn variant_from(value: GuiChart) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiChart> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiChart::from(idisp))
        }
    }
    pub struct GuiCheckBox {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiCheckBox {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiCheckBoxExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn color_index(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ColorIndex")?.variant_into()?,
            )
        }
        fn color_intensified(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ColorIntensified")?.variant_into()?,
            )
        }
        fn color_inverse(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ColorInverse")?.variant_into()?,
            )
        }
        fn flushing(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Flushing")?.variant_into()?,
            )
        }
        fn is_left_label(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsLeftLabel")?.variant_into()?,
            )
        }
        fn is_list_element(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsListElement")?.variant_into()?,
            )
        }
        fn is_right_label(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsRightLabel")?.variant_into()?,
            )
        }
        fn left_label(&self) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("LeftLabel")?.variant_into()?,
            )
        }
        fn right_label(&self) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("RightLabel")?.variant_into()?,
            )
        }
        fn row_text(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("RowText")?.variant_into()?,
            )
        }
        fn selected(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Selected")?.variant_into()?,
            )
        }
        fn set_selected(&self, value: bool) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("Selected", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn get_list_property(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetListProperty",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_list_property_non_rec(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetListPropertyNonRec",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
    }
    impl GuiCheckBoxExt for GuiCheckBox {}
    impl GuiVComponentExt for GuiCheckBox {}
    impl GuiComponentExt for GuiCheckBox {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiCheckBox {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiCheckBox> for ::com_shim::VARIANT {
        fn variant_from(value: GuiCheckBox) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiCheckBox> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiCheckBox::from(idisp))
        }
    }
    pub struct GuiCollection {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiCollection {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiCollectionExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn count(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Count")?.variant_into()?)
        }
        fn length(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Length")?.variant_into()?,
            )
        }
        fn r#type(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Type")?.variant_into()?)
        }
        fn type_as_number(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("TypeAsNumber")?.variant_into()?,
            )
        }
        fn element_at(&self, p0: i32) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "ElementAt",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
    }
    impl GuiCollectionExt for GuiCollection {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiCollection {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiCollection> for ::com_shim::VARIANT {
        fn variant_from(value: GuiCollection) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiCollection> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiCollection::from(idisp))
        }
    }
    pub struct GuiColorSelector {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiColorSelector {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiColorSelectorExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn change_selection(&self, p0: i16) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "ChangeSelection",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiColorSelectorExt for GuiColorSelector {}
    impl GuiVContainerExt for GuiColorSelector {}
    impl GuiVComponentExt for GuiColorSelector {}
    impl GuiContainerExt for GuiColorSelector {}
    impl GuiComponentExt for GuiColorSelector {}
    impl GuiShellExt for GuiColorSelector {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiColorSelector {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiColorSelector> for ::com_shim::VARIANT {
        fn variant_from(value: GuiColorSelector) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiColorSelector> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiColorSelector::from(idisp))
        }
    }
    pub struct GuiComboBox {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiComboBox {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiComboBoxExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn char_height(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharHeight")?.variant_into()?,
            )
        }
        fn char_left(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharLeft")?.variant_into()?,
            )
        }
        fn char_top(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharTop")?.variant_into()?,
            )
        }
        fn char_width(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharWidth")?.variant_into()?,
            )
        }
        fn cur_list_box_entry(&self) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CurListBoxEntry")?.variant_into()?,
            )
        }
        fn entries(&self) -> ::com_shim::Result<GuiCollection> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Entries")?.variant_into()?,
            )
        }
        fn flushing(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Flushing")?.variant_into()?,
            )
        }
        fn highlighted(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Highlighted")?.variant_into()?,
            )
        }
        fn is_left_label(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsLeftLabel")?.variant_into()?,
            )
        }
        fn is_list_box_active(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsListBoxActive")?.variant_into()?,
            )
        }
        fn is_right_label(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsRightLabel")?.variant_into()?,
            )
        }
        fn key(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Key")?.variant_into()?)
        }
        fn set_key(&self, value: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("Key", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn left_label(&self) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("LeftLabel")?.variant_into()?,
            )
        }
        fn required(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Required")?.variant_into()?,
            )
        }
        fn right_label(&self) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("RightLabel")?.variant_into()?,
            )
        }
        fn show_key(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ShowKey")?.variant_into()?,
            )
        }
        fn text(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Text")?.variant_into()?)
        }
        fn value(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Value")?.variant_into()?)
        }
        fn set_value(&self, value: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("Value", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn set_key_space(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("SetKeySpace", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiComboBoxExt for GuiComboBox {}
    impl GuiVComponentExt for GuiComboBox {}
    impl GuiComponentExt for GuiComboBox {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiComboBox {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiComboBox> for ::com_shim::VARIANT {
        fn variant_from(value: GuiComboBox) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiComboBox> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiComboBox::from(idisp))
        }
    }
    pub struct GuiComboBoxControl {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiComboBoxControl {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiComboBoxControlExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn cur_list_box_entry(&self) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CurListBoxEntry")?.variant_into()?,
            )
        }
        fn entries(&self) -> ::com_shim::Result<GuiCollection> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Entries")?.variant_into()?,
            )
        }
        fn is_list_box_active(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsListBoxActive")?.variant_into()?,
            )
        }
        fn label_text(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("LabelText")?.variant_into()?,
            )
        }
        fn selected(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Selected")?.variant_into()?,
            )
        }
        fn set_selected(&self, value: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("Selected", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn text(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Text")?.variant_into()?)
        }
        fn fire_selected(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("FireSelected", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiComboBoxControlExt for GuiComboBoxControl {}
    impl GuiVComponentExt for GuiComboBoxControl {}
    impl GuiVContainerExt for GuiComboBoxControl {}
    impl GuiComponentExt for GuiComboBoxControl {}
    impl GuiContainerExt for GuiComboBoxControl {}
    impl GuiShellExt for GuiComboBoxControl {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiComboBoxControl {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiComboBoxControl> for ::com_shim::VARIANT {
        fn variant_from(value: GuiComboBoxControl) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiComboBoxControl> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiComboBoxControl::from(idisp))
        }
    }
    pub struct GuiComboBoxEntry {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiComboBoxEntry {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiComboBoxEntryExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn key(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Key")?.variant_into()?)
        }
        fn pos(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Pos")?.variant_into()?)
        }
        fn value(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Value")?.variant_into()?)
        }
    }
    impl GuiComboBoxEntryExt for GuiComboBoxEntry {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiComboBoxEntry {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiComboBoxEntry> for ::com_shim::VARIANT {
        fn variant_from(value: GuiComboBoxEntry) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiComboBoxEntry> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiComboBoxEntry::from(idisp))
        }
    }
    pub struct GuiComponent {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiComponent {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiComponentExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn container_type(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ContainerType")?.variant_into()?,
            )
        }
        fn id(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Id")?.variant_into()?)
        }
        fn name(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Name")?.variant_into()?)
        }
        fn r_type(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("r#Type")?.variant_into()?,
            )
        }
        fn type_as_number(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("TypeAsNumber")?.variant_into()?,
            )
        }
    }
    impl GuiComponentExt for GuiComponent {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiComponent {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiComponent> for ::com_shim::VARIANT {
        fn variant_from(value: GuiComponent) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiComponent> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiComponent::from(idisp))
        }
    }
    pub struct GuiComponentCollection {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiComponentCollection {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiComponentCollectionExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn count(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Count")?.variant_into()?)
        }
        fn length(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Length")?.variant_into()?,
            )
        }
        fn r_type(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("r#Type")?.variant_into()?,
            )
        }
        fn type_as_number(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("TypeAsNumber")?.variant_into()?,
            )
        }
        fn element_at(&self, p0: i32) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "ElementAt",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
    }
    impl GuiComponentCollectionExt for GuiComponentCollection {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiComponentCollection {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiComponentCollection> for ::com_shim::VARIANT {
        fn variant_from(value: GuiComponentCollection) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiComponentCollection> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiComponentCollection::from(idisp))
        }
    }
    pub struct GuiConnection {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiConnection {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiConnectionExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn children(&self) -> ::com_shim::Result<GuiComponentCollection> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Children")?.variant_into()?,
            )
        }
        fn connection_string(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ConnectionString")?.variant_into()?,
            )
        }
        fn description(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Description")?.variant_into()?,
            )
        }
        fn disabled_by_server(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("DisabledByServer")?.variant_into()?,
            )
        }
        fn sessions(&self) -> ::com_shim::Result<GuiComponentCollection> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Sessions")?.variant_into()?,
            )
        }
        fn close_connection(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("CloseConnection", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn close_session(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "CloseSession",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiConnectionExt for GuiConnection {}
    impl GuiContainerExt for GuiConnection {}
    impl GuiComponentExt for GuiConnection {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiConnection {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiConnection> for ::com_shim::VARIANT {
        fn variant_from(value: GuiConnection) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiConnection> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiConnection::from(idisp))
        }
    }
    pub struct GuiContainer {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiContainer {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiContainerExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn children(&self) -> ::com_shim::Result<GuiComponentCollection> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Children")?.variant_into()?,
            )
        }
        fn find_by_id(&self, p0: String) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "FindById",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
    }
    impl GuiContainerExt for GuiContainer {}
    impl GuiComponentExt for GuiContainer {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiContainer {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiContainer> for ::com_shim::VARIANT {
        fn variant_from(value: GuiContainer) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiContainer> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiContainer::from(idisp))
        }
    }
    pub struct GuiContainerShell {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiContainerShell {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiContainerShellExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn acc_description(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("AccDescription")?.variant_into()?,
            )
        }
    }
    impl GuiContainerShellExt for GuiContainerShell {}
    impl GuiVContainerExt for GuiContainerShell {}
    impl GuiVComponentExt for GuiContainerShell {}
    impl GuiContainerExt for GuiContainerShell {}
    impl GuiComponentExt for GuiContainerShell {}
    impl GuiShellExt for GuiContainerShell {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiContainerShell {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiContainerShell> for ::com_shim::VARIANT {
        fn variant_from(value: GuiContainerShell) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiContainerShell> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiContainerShell::from(idisp))
        }
    }
    pub struct GuiCTextField {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiCTextField {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiCTextFieldExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {}
    impl GuiCTextFieldExt for GuiCTextField {}
    impl GuiTextFieldExt for GuiCTextField {}
    impl GuiVComponentExt for GuiCTextField {}
    impl GuiComponentExt for GuiCTextField {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiCTextField {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiCTextField> for ::com_shim::VARIANT {
        fn variant_from(value: GuiCTextField) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiCTextField> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiCTextField::from(idisp))
        }
    }
    pub struct GuiCustomControl {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiCustomControl {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiCustomControlExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn char_height(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharHeight")?.variant_into()?,
            )
        }
        fn char_left(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharLeft")?.variant_into()?,
            )
        }
        fn char_top(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharTop")?.variant_into()?,
            )
        }
        fn char_width(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharWidth")?.variant_into()?,
            )
        }
    }
    impl GuiCustomControlExt for GuiCustomControl {}
    impl GuiVContainerExt for GuiCustomControl {}
    impl GuiVComponentExt for GuiCustomControl {}
    impl GuiContainerExt for GuiCustomControl {}
    impl GuiComponentExt for GuiCustomControl {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiCustomControl {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiCustomControl> for ::com_shim::VARIANT {
        fn variant_from(value: GuiCustomControl) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiCustomControl> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiCustomControl::from(idisp))
        }
    }
    pub struct GuiDialogShell {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiDialogShell {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiDialogShellExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn title(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Title")?.variant_into()?)
        }
        fn close(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("Close", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiDialogShellExt for GuiDialogShell {}
    impl GuiVContainerExt for GuiDialogShell {}
    impl GuiVComponentExt for GuiDialogShell {}
    impl GuiContainerExt for GuiDialogShell {}
    impl GuiComponentExt for GuiDialogShell {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiDialogShell {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiDialogShell> for ::com_shim::VARIANT {
        fn variant_from(value: GuiDialogShell) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiDialogShell> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiDialogShell::from(idisp))
        }
    }
    pub struct GuiDockShell {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiDockShell {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiDockShellExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn acc_description(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("AccDescription")?.variant_into()?,
            )
        }
        fn docker_is_vertical(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("DockerIsVertical")?.variant_into()?,
            )
        }
        fn docker_pixel_size(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("DockerPixelSize")?.variant_into()?,
            )
        }
        fn set_docker_pixel_size(&self, value: i32) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("DockerPixelSize", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiDockShellExt for GuiDockShell {}
    impl GuiVContainerExt for GuiDockShell {}
    impl GuiVComponentExt for GuiDockShell {}
    impl GuiContainerExt for GuiDockShell {}
    impl GuiComponentExt for GuiDockShell {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiDockShell {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiDockShell> for ::com_shim::VARIANT {
        fn variant_from(value: GuiDockShell) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiDockShell> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiDockShell::from(idisp))
        }
    }
    pub struct GuiEAIViewer2D {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiEAIViewer2D {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiEAIViewer2DExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn annoutation_enabled(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("AnnoutationEnabled")?.variant_into()?,
            )
        }
        fn set_annoutation_enabled(&self, value: i32) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("AnnoutationEnabled", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn annotation_mode(&self) -> ::com_shim::Result<i16> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("AnnotationMode")?.variant_into()?,
            )
        }
        fn set_annotation_mode(&self, value: i16) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("AnnotationMode", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn redlining_stream(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("RedliningStream")?.variant_into()?,
            )
        }
        fn set_redlining_stream(&self, value: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("RedliningStream", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn annotation_text_request(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "annotationTextRequest",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiEAIViewer2DExt for GuiEAIViewer2D {}
    impl GuiVContainerExt for GuiEAIViewer2D {}
    impl GuiVComponentExt for GuiEAIViewer2D {}
    impl GuiContainerExt for GuiEAIViewer2D {}
    impl GuiComponentExt for GuiEAIViewer2D {}
    impl GuiShellExt for GuiEAIViewer2D {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiEAIViewer2D {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiEAIViewer2D> for ::com_shim::VARIANT {
        fn variant_from(value: GuiEAIViewer2D) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiEAIViewer2D> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiEAIViewer2D::from(idisp))
        }
    }
    pub struct GuiEAIViewer3D {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiEAIViewer3D {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiEAIViewer3DExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {}
    impl GuiEAIViewer3DExt for GuiEAIViewer3D {}
    impl GuiVContainerExt for GuiEAIViewer3D {}
    impl GuiVComponentExt for GuiEAIViewer3D {}
    impl GuiContainerExt for GuiEAIViewer3D {}
    impl GuiComponentExt for GuiEAIViewer3D {}
    impl GuiShellExt for GuiEAIViewer3D {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiEAIViewer3D {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiEAIViewer3D> for ::com_shim::VARIANT {
        fn variant_from(value: GuiEAIViewer3D) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiEAIViewer3D> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiEAIViewer3D::from(idisp))
        }
    }
    pub struct GuiFrameWindow {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiFrameWindow {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiFrameWindowExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn element_visualization_mode(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ElementVisualizationMode")?.variant_into()?,
            )
        }
        fn set_element_visualization_mode(&self, value: bool) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set(
                    "ElementVisualizationMode",
                    ::com_shim::VARIANT::variant_from(value),
                )?;
            ::std::result::Result::Ok(())
        }
        fn gui_focus(&self) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("GuiFocus")?.variant_into()?,
            )
        }
        fn handle(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Handle")?.variant_into()?,
            )
        }
        fn iconic(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Iconic")?.variant_into()?,
            )
        }
        fn system_focus(&self) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("SystemFocus")?.variant_into()?,
            )
        }
        fn working_pane_height(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("WorkingPaneHeight")?.variant_into()?,
            )
        }
        fn working_pane_width(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("WorkingPaneWidth")?.variant_into()?,
            )
        }
        fn close(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("Close", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn comp_bitmap(&self, p0: String, p1: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("CompBitmap", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn hard_copy(&self, p0: String, p1: i16) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("HardCopy", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn iconify(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("Iconify", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn is_v_key_allowed(&self, p0: i16) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "IsVKeyAllowed",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn jump_backward(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("JumpBackward", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn jump_forward(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("JumpForward", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn maximize(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("Maximize", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn restore(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("Restore", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn send_v_key(&self, p0: i16) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "SendVKey",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn show_message_box(
            &self,
            p0: String,
            p1: String,
            p2: i32,
            p3: i32,
        ) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("ShowMessageBox", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn tab_backward(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("TabBackward", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn tab_forward(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("TabForward", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiFrameWindowExt for GuiFrameWindow {}
    impl GuiVContainerExt for GuiFrameWindow {}
    impl GuiVComponentExt for GuiFrameWindow {}
    impl GuiContainerExt for GuiFrameWindow {}
    impl GuiComponentExt for GuiFrameWindow {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiFrameWindow {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiFrameWindow> for ::com_shim::VARIANT {
        fn variant_from(value: GuiFrameWindow) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiFrameWindow> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiFrameWindow::from(idisp))
        }
    }
    pub struct GuiGOSShell {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiGOSShell {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiGOSShellExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {}
    impl GuiGOSShellExt for GuiGOSShell {}
    impl GuiVContainerExt for GuiGOSShell {}
    impl GuiVComponentExt for GuiGOSShell {}
    impl GuiContainerExt for GuiGOSShell {}
    impl GuiComponentExt for GuiGOSShell {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiGOSShell {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiGOSShell> for ::com_shim::VARIANT {
        fn variant_from(value: GuiGOSShell) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiGOSShell> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiGOSShell::from(idisp))
        }
    }
    pub struct GuiGraphAdapt {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiGraphAdapt {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiGraphAdaptExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {}
    impl GuiGraphAdaptExt for GuiGraphAdapt {}
    impl GuiVComponentExt for GuiGraphAdapt {}
    impl GuiVContainerExt for GuiGraphAdapt {}
    impl GuiContainerExt for GuiGraphAdapt {}
    impl GuiComponentExt for GuiGraphAdapt {}
    impl GuiShellExt for GuiGraphAdapt {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiGraphAdapt {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiGraphAdapt> for ::com_shim::VARIANT {
        fn variant_from(value: GuiGraphAdapt) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiGraphAdapt> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiGraphAdapt::from(idisp))
        }
    }
    pub struct GuiGridView {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiGridView {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiGridViewExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn column_count(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ColumnCount")?.variant_into()?,
            )
        }
        fn current_cell_column(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CurrentCellColumn")?.variant_into()?,
            )
        }
        fn set_current_cell_column(&self, value: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("CurrentCellColumn", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn current_cell_row(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CurrentCellRow")?.variant_into()?,
            )
        }
        fn set_current_cell_row(&self, value: i32) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("CurrentCellRow", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn first_visible_column(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("FirstVisibleColumn")?.variant_into()?,
            )
        }
        fn set_first_visible_column(&self, value: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("FirstVisibleColumn", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn first_visible_row(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("FirstVisibleRow")?.variant_into()?,
            )
        }
        fn set_first_visible_row(&self, value: i32) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("FirstVisibleRow", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn frozen_column_count(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("FrozenColumnCount")?.variant_into()?,
            )
        }
        fn row_count(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("RowCount")?.variant_into()?,
            )
        }
        fn selected_rows(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("SelectedRows")?.variant_into()?,
            )
        }
        fn set_selected_rows(&self, value: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("SelectedRows", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn selection_mode(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("SelectionMode")?.variant_into()?,
            )
        }
        fn title(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Title")?.variant_into()?)
        }
        fn toolbar_button_count(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ToolbarButtonCount")?.variant_into()?,
            )
        }
        fn visible_row_count(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("VisibleRowCount")?.variant_into()?,
            )
        }
        fn clear_selection(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("ClearSelection", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn click(&self, p0: i32, p1: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("Click", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn click_current_cell(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("ClickCurrentCell", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn context_menu(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("ContextMenu", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn current_cell_moved(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("CurrentCellMoved", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn delete_rows(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "DeleteRows",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn deselect_column(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "DeselectColumn",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn double_click(&self, p0: i32, p1: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("DoubleClick", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn double_click_current_cell(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("DoubleClickCurrentCell", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn duplicate_rows(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "DuplicateRows",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn get_cell_changeable(&self, p0: i32, p1: String) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetCellChangeable", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_cell_check_box_checked(
            &self,
            p0: i32,
            p1: String,
        ) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetCellCheckBoxChecked", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_cell_color(&self, p0: i32, p1: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetCellColor", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_cell_height(&self, p0: i32, p1: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetCellHeight", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_cell_hotspot_type(
            &self,
            p0: i32,
            p1: String,
        ) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetCellHotspotType", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_cell_icon(&self, p0: i32, p1: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetCellIcon", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_cell_left(&self, p0: i32, p1: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetCellLeft", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_cell_list_box_count(
            &self,
            p0: i32,
            p1: String,
        ) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetCellListBoxCount", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_cell_list_box_cur_index(
            &self,
            p0: i32,
            p1: String,
        ) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetCellListBoxCurIndex", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_cell_max_length(&self, p0: i32, p1: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetCellMaxLength", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_cell_state(&self, p0: i32, p1: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetCellState", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_cell_tooltip(&self, p0: i32, p1: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetCellTooltip", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_cell_top(&self, p0: i32, p1: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetCellTop", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_cell_type(&self, p0: i32, p1: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetCellType", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_cell_value(&self, p0: i32, p1: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetCellValue", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_cell_width(&self, p0: i32, p1: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetCellWidth", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_color_info(&self, p0: i32) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetColorInfo",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_column_data_type(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetColumnDataType",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_column_operation_type(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetColumnOperationType",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_column_position(&self, p0: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetColumnPosition",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_column_sort_type(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetColumnSortType",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_column_tooltip(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetColumnTooltip",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_column_total_type(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetColumnTotalType",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_displayed_column_title(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetDisplayedColumnTitle",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_row_total_level(&self, p0: i32) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetRowTotalLevel",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_symbol_info(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetSymbolInfo",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_toolbar_button_checked(&self, p0: i32) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetToolbarButtonChecked",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_toolbar_button_enabled(&self, p0: i32) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetToolbarButtonEnabled",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_toolbar_button_icon(&self, p0: i32) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetToolbarButtonIcon",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_toolbar_button_id(&self, p0: i32) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetToolbarButtonId",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_toolbar_button_text(&self, p0: i32) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetToolbarButtonText",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_toolbar_button_tooltip(&self, p0: i32) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetToolbarButtonTooltip",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_toolbar_button_type(&self, p0: i32) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetToolbarButtonType",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_toolbar_focus_button(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("GetToolbarFocusButton", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn has_cell_f4_help(&self, p0: i32, p1: String) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("HasCellF4Help", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn history_cur_entry(&self, p0: i32, p1: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("HistoryCurEntry", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn history_cur_index(&self, p0: i32, p1: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("HistoryCurIndex", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn history_is_active(&self, p0: i32, p1: String) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("HistoryIsActive", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn history_list(
            &self,
            p0: i32,
            p1: String,
        ) -> ::com_shim::Result<GuiCollection> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("HistoryList", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn insert_rows(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "InsertRows",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn is_cell_hotspot(&self, p0: i32, p1: String) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("IsCellHotspot", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn is_cell_symbol(&self, p0: i32, p1: String) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("IsCellSymbol", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn is_cell_total_expander(
            &self,
            p0: i32,
            p1: String,
        ) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("IsCellTotalExpander", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn is_column_filtered(&self, p0: String) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "IsColumnFiltered",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn is_column_key(&self, p0: String) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "IsColumnKey",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn is_total_row_expanded(&self, p0: i32) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "IsTotalRowExpanded",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn modify_cell(
            &self,
            p0: i32,
            p1: String,
            p2: String,
        ) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("ModifyCell", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn modify_check_box(
            &self,
            p0: i32,
            p1: String,
            p2: bool,
        ) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("ModifyCheckBox", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn move_rows(&self, p0: i32, p1: i32, p2: i32) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("MoveRows", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn press_button(&self, p0: i32, p1: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("PressButton", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn press_button_current_cell(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("PressButtonCurrentCell", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn press_column_header(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "PressColumnHeader",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn press_enter(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("PressEnter", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn press_f1(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("PressF1", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn press_f4(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("PressF4", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn press_toolbar_button(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "PressToolbarButton",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn press_toolbar_context_button(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "PressToolbarContextButton",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn press_total_row(&self, p0: i32, p1: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("PressTotalRow", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn press_total_row_current_cell(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("PressTotalRowCurrentCell", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn select_all(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("SelectAll", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn select_column(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "SelectColumn",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn selection_changed(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("SelectionChanged", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn select_toolbar_menu_item(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "SelectToolbarMenuItem",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn set_column_width(&self, p0: String, p1: i32) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("SetColumnWidth", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn set_current_cell(&self, p0: i32, p1: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("SetCurrentCell", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn trigger_modified(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("TriggerModified", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiGridViewExt for GuiGridView {}
    impl GuiVComponentExt for GuiGridView {}
    impl GuiVContainerExt for GuiGridView {}
    impl GuiComponentExt for GuiGridView {}
    impl GuiContainerExt for GuiGridView {}
    impl GuiShellExt for GuiGridView {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiGridView {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiGridView> for ::com_shim::VARIANT {
        fn variant_from(value: GuiGridView) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiGridView> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiGridView::from(idisp))
        }
    }
    pub struct GuiHTMLViewer {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiHTMLViewer {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiHTMLViewerExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn document_complete(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("DocumentComplete")?.variant_into()?,
            )
        }
        fn context_menu(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("ContextMenu", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn get_brower_control_type(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("GetBrowerControlType", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn sap_event(
            &self,
            p0: String,
            p1: String,
            p2: String,
        ) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("SapEvent", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiHTMLViewerExt for GuiHTMLViewer {}
    impl GuiVComponentExt for GuiHTMLViewer {}
    impl GuiVContainerExt for GuiHTMLViewer {}
    impl GuiComponentExt for GuiHTMLViewer {}
    impl GuiContainerExt for GuiHTMLViewer {}
    impl GuiShellExt for GuiHTMLViewer {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiHTMLViewer {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiHTMLViewer> for ::com_shim::VARIANT {
        fn variant_from(value: GuiHTMLViewer) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiHTMLViewer> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiHTMLViewer::from(idisp))
        }
    }
    pub struct GuiInputFieldControl {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiInputFieldControl {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiInputFieldControlExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn button_tooltip(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ButtonTooltip")?.variant_into()?,
            )
        }
        fn find_button_activated(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("FindButtonActivated")?.variant_into()?,
            )
        }
        fn history_cur_entry(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("HistoryCurEntry")?.variant_into()?,
            )
        }
        fn history_cur_index(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("HistoryCurIndex")?.variant_into()?,
            )
        }
        fn history_is_active(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("HistoryIsActive")?.variant_into()?,
            )
        }
        fn history_list(&self) -> ::com_shim::Result<GuiCollection> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("HistoryList")?.variant_into()?,
            )
        }
        fn label_text(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("LabelText")?.variant_into()?,
            )
        }
        fn prompt_text(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("PromptText")?.variant_into()?,
            )
        }
        fn submit(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("Submit", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiInputFieldControlExt for GuiInputFieldControl {}
    impl GuiVComponentExt for GuiInputFieldControl {}
    impl GuiVContainerExt for GuiInputFieldControl {}
    impl GuiComponentExt for GuiInputFieldControl {}
    impl GuiContainerExt for GuiInputFieldControl {}
    impl GuiShellExt for GuiInputFieldControl {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiInputFieldControl {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiInputFieldControl> for ::com_shim::VARIANT {
        fn variant_from(value: GuiInputFieldControl) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiInputFieldControl> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiInputFieldControl::from(idisp))
        }
    }
    pub struct GuiLabel {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiLabel {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiLabelExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn caret_position(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CaretPosition")?.variant_into()?,
            )
        }
        fn set_caret_position(&self, value: i32) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("CaretPosition", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn char_height(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharHeight")?.variant_into()?,
            )
        }
        fn char_left(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharLeft")?.variant_into()?,
            )
        }
        fn char_top(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharTop")?.variant_into()?,
            )
        }
        fn char_width(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharWidth")?.variant_into()?,
            )
        }
        fn color_index(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ColorIndex")?.variant_into()?,
            )
        }
        fn color_intensified(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ColorIntensified")?.variant_into()?,
            )
        }
        fn color_inverse(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ColorInverse")?.variant_into()?,
            )
        }
        fn displayed_text(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("DisplayedText")?.variant_into()?,
            )
        }
        fn highlighted(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Highlighted")?.variant_into()?,
            )
        }
        fn is_hotspot(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsHotspot")?.variant_into()?,
            )
        }
        fn is_left_label(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsLeftLabel")?.variant_into()?,
            )
        }
        fn is_list_element(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsListElement")?.variant_into()?,
            )
        }
        fn is_right_label(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsRightLabel")?.variant_into()?,
            )
        }
        fn max_length(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("MaxLength")?.variant_into()?,
            )
        }
        fn numerical(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Numerical")?.variant_into()?,
            )
        }
        fn row_text(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("RowText")?.variant_into()?,
            )
        }
        fn get_list_property(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetListProperty",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_list_property_non_rec(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetListPropertyNonRec",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
    }
    impl GuiLabelExt for GuiLabel {}
    impl GuiVComponentExt for GuiLabel {}
    impl GuiComponentExt for GuiLabel {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiLabel {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiLabel> for ::com_shim::VARIANT {
        fn variant_from(value: GuiLabel) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiLabel> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiLabel::from(idisp))
        }
    }
    pub struct GuiMainWindow {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiMainWindow {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiMainWindowExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn buttonbar_visible(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ButtonbarVisible")?.variant_into()?,
            )
        }
        fn set_buttonbar_visible(&self, value: bool) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("ButtonbarVisible", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn statusbar_visible(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("StatusbarVisible")?.variant_into()?,
            )
        }
        fn set_statusbar_visible(&self, value: bool) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("StatusbarVisible", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn titlebar_visible(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("TitlebarVisible")?.variant_into()?,
            )
        }
        fn set_titlebar_visible(&self, value: bool) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("TitlebarVisible", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn toolbar_visible(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ToolbarVisible")?.variant_into()?,
            )
        }
        fn set_toolbar_visible(&self, value: bool) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("ToolbarVisible", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn resize_working_pane(
            &self,
            p0: i32,
            p1: i32,
            p2: bool,
        ) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("ResizeWorkingPane", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn resize_working_pane_ex(
            &self,
            p0: i32,
            p1: i32,
            p2: bool,
        ) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("ResizeWorkingPaneEx", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiMainWindowExt for GuiMainWindow {}
    impl GuiFrameWindowExt for GuiMainWindow {}
    impl GuiVComponentExt for GuiMainWindow {}
    impl GuiVContainerExt for GuiMainWindow {}
    impl GuiContainerExt for GuiMainWindow {}
    impl GuiComponentExt for GuiMainWindow {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiMainWindow {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiMainWindow> for ::com_shim::VARIANT {
        fn variant_from(value: GuiMainWindow) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiMainWindow> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiMainWindow::from(idisp))
        }
    }
    pub struct GuiMap {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiMap {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiMapExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {}
    impl GuiMapExt for GuiMap {}
    impl GuiVComponentExt for GuiMap {}
    impl GuiVContainerExt for GuiMap {}
    impl GuiComponentExt for GuiMap {}
    impl GuiContainerExt for GuiMap {}
    impl GuiShellExt for GuiMap {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiMap {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiMap> for ::com_shim::VARIANT {
        fn variant_from(value: GuiMap) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiMap> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiMap::from(idisp))
        }
    }
    pub struct GuiMenu {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiMenu {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiMenuExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn select(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("Select", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiMenuExt for GuiMenu {}
    impl GuiVContainerExt for GuiMenu {}
    impl GuiVComponentExt for GuiMenu {}
    impl GuiContainerExt for GuiMenu {}
    impl GuiComponentExt for GuiMenu {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiMenu {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiMenu> for ::com_shim::VARIANT {
        fn variant_from(value: GuiMenu) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiMenu> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiMenu::from(idisp))
        }
    }
    pub struct GuiMenubar {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiMenubar {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiMenubarExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {}
    impl GuiMenubarExt for GuiMenubar {}
    impl GuiVContainerExt for GuiMenubar {}
    impl GuiVComponentExt for GuiMenubar {}
    impl GuiContainerExt for GuiMenubar {}
    impl GuiComponentExt for GuiMenubar {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiMenubar {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiMenubar> for ::com_shim::VARIANT {
        fn variant_from(value: GuiMenubar) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiMenubar> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiMenubar::from(idisp))
        }
    }
    pub struct GuiMessageWindow {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiMessageWindow {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiMessageWindowExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn focused_button(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("FocusedButton")?.variant_into()?,
            )
        }
        fn help_button_help_text(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("HelpButtonHelpText")?.variant_into()?,
            )
        }
        fn help_button_text(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("HelpButtonText")?.variant_into()?,
            )
        }
        fn message_text(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("MessageText")?.variant_into()?,
            )
        }
        fn message_type(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("MessageType")?.variant_into()?,
            )
        }
        fn ok_button_help_text(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("OKButtonHelpText")?.variant_into()?,
            )
        }
        fn ok_button_text(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("OKButtonText")?.variant_into()?,
            )
        }
        fn screen_left(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ScreenLeft")?.variant_into()?,
            )
        }
        fn screen_top(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ScreenTop")?.variant_into()?,
            )
        }
        fn visible(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Visible")?.variant_into()?,
            )
        }
    }
    impl GuiMessageWindowExt for GuiMessageWindow {}
    impl GuiVComponentExt for GuiMessageWindow {}
    impl GuiComponentExt for GuiMessageWindow {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiMessageWindow {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiMessageWindow> for ::com_shim::VARIANT {
        fn variant_from(value: GuiMessageWindow) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiMessageWindow> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiMessageWindow::from(idisp))
        }
    }
    pub struct GuiModalWindow {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiModalWindow {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiModalWindowExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn is_popup_dialog(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("IsPopupDialog", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn popup_dialog_text(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("PopupDialogText", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
    }
    impl GuiModalWindowExt for GuiModalWindow {}
    impl GuiFrameWindowExt for GuiModalWindow {}
    impl GuiVComponentExt for GuiModalWindow {}
    impl GuiVContainerExt for GuiModalWindow {}
    impl GuiComponentExt for GuiModalWindow {}
    impl GuiContainerExt for GuiModalWindow {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiModalWindow {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiModalWindow> for ::com_shim::VARIANT {
        fn variant_from(value: GuiModalWindow) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiModalWindow> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiModalWindow::from(idisp))
        }
    }
    pub struct GuiNetChart {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiNetChart {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiNetChartExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn link_count(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("LinkCount")?.variant_into()?,
            )
        }
        fn node_count(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("NodeCount")?.variant_into()?,
            )
        }
        fn get_link_content(&self, p0: i32, p1: i32) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetLinkContent", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_node_content(&self, p0: i32, p1: i32) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetNodeContent", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn send_data(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "SendData",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiNetChartExt for GuiNetChart {}
    impl GuiVComponentExt for GuiNetChart {}
    impl GuiVContainerExt for GuiNetChart {}
    impl GuiComponentExt for GuiNetChart {}
    impl GuiContainerExt for GuiNetChart {}
    impl GuiShellExt for GuiNetChart {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiNetChart {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiNetChart> for ::com_shim::VARIANT {
        fn variant_from(value: GuiNetChart) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiNetChart> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiNetChart::from(idisp))
        }
    }
    pub struct GuiOfficeIntegration {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiOfficeIntegration {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiOfficeIntegrationExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn hosted_application(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("HostedApplication")?.variant_into()?,
            )
        }
        fn append_row(&self, p0: String, p1: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("AppendRow", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn close_document(&self, p0: i32, p1: bool, p2: bool) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("CloseDocument", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn remove_content(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "RemoveContent",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn save_document(&self, p0: i32, p1: bool) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("SaveDocument", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn set_document(&self, p0: i32, p1: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("SetDocument", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiOfficeIntegrationExt for GuiOfficeIntegration {}
    impl GuiVContainerExt for GuiOfficeIntegration {}
    impl GuiVComponentExt for GuiOfficeIntegration {}
    impl GuiContainerExt for GuiOfficeIntegration {}
    impl GuiComponentExt for GuiOfficeIntegration {}
    impl GuiShellExt for GuiOfficeIntegration {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiOfficeIntegration {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiOfficeIntegration> for ::com_shim::VARIANT {
        fn variant_from(value: GuiOfficeIntegration) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiOfficeIntegration> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiOfficeIntegration::from(idisp))
        }
    }
    pub struct GuiOkCodeField {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiOkCodeField {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiOkCodeFieldExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn opened(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Opened")?.variant_into()?,
            )
        }
        fn press_f1(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("PressF1", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiOkCodeFieldExt for GuiOkCodeField {}
    impl GuiVComponentExt for GuiOkCodeField {}
    impl GuiComponentExt for GuiOkCodeField {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiOkCodeField {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiOkCodeField> for ::com_shim::VARIANT {
        fn variant_from(value: GuiOkCodeField) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiOkCodeField> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiOkCodeField::from(idisp))
        }
    }
    pub struct GuiPasswordField {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiPasswordField {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiPasswordFieldExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {}
    impl GuiPasswordFieldExt for GuiPasswordField {}
    impl GuiTextFieldExt for GuiPasswordField {}
    impl GuiVComponentExt for GuiPasswordField {}
    impl GuiComponentExt for GuiPasswordField {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiPasswordField {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiPasswordField> for ::com_shim::VARIANT {
        fn variant_from(value: GuiPasswordField) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiPasswordField> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiPasswordField::from(idisp))
        }
    }
    pub struct GuiPicture {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiPicture {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiPictureExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn alt_text(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("AltText")?.variant_into()?,
            )
        }
        fn display_mode(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("DisplayMode")?.variant_into()?,
            )
        }
        fn icon(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Icon")?.variant_into()?)
        }
        fn url(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Url")?.variant_into()?)
        }
        fn click(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("Click", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn click_control_area(&self, p0: i32, p1: i32) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("ClickControlArea", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn click_picture_area(&self, p0: i32, p1: i32) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("ClickPictureArea", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn context_menu(&self, p0: i32, p1: i32) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("ContextMenu", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn double_click(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("DoubleClick", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn double_click_control_area(&self, p0: i32, p1: i32) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("DoubleClickControlArea", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn double_click_picture_area(&self, p0: i32, p1: i32) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("DoubleClickPictureArea", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiPictureExt for GuiPicture {}
    impl GuiVComponentExt for GuiPicture {}
    impl GuiVContainerExt for GuiPicture {}
    impl GuiComponentExt for GuiPicture {}
    impl GuiContainerExt for GuiPicture {}
    impl GuiShellExt for GuiPicture {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiPicture {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiPicture> for ::com_shim::VARIANT {
        fn variant_from(value: GuiPicture) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiPicture> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiPicture::from(idisp))
        }
    }
    pub struct GuiRadioButton {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiRadioButton {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiRadioButtonExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn char_height(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharHeight")?.variant_into()?,
            )
        }
        fn char_left(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharLeft")?.variant_into()?,
            )
        }
        fn char_top(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharTop")?.variant_into()?,
            )
        }
        fn char_width(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharWidth")?.variant_into()?,
            )
        }
        fn flushing(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Flushing")?.variant_into()?,
            )
        }
        fn group_count(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("GroupCount")?.variant_into()?,
            )
        }
        fn group_members(&self) -> ::com_shim::Result<GuiComponentCollection> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("GroupMembers")?.variant_into()?,
            )
        }
        fn group_pos(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("GroupPos")?.variant_into()?,
            )
        }
        fn is_left_label(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsLeftLabel")?.variant_into()?,
            )
        }
        fn is_right_label(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsRightLabel")?.variant_into()?,
            )
        }
        fn left_label(&self) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("LeftLabel")?.variant_into()?,
            )
        }
        fn right_label(&self) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("RightLabel")?.variant_into()?,
            )
        }
        fn selected(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Selected")?.variant_into()?,
            )
        }
        fn select(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("Select", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiRadioButtonExt for GuiRadioButton {}
    impl GuiVComponentExt for GuiRadioButton {}
    impl GuiComponentExt for GuiRadioButton {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiRadioButton {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiRadioButton> for ::com_shim::VARIANT {
        fn variant_from(value: GuiRadioButton) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiRadioButton> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiRadioButton::from(idisp))
        }
    }
    pub struct GuiSapChart {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiSapChart {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiSapChartExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {}
    impl GuiSapChartExt for GuiSapChart {}
    impl GuiVComponentExt for GuiSapChart {}
    impl GuiVContainerExt for GuiSapChart {}
    impl GuiComponentExt for GuiSapChart {}
    impl GuiContainerExt for GuiSapChart {}
    impl GuiShellExt for GuiSapChart {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiSapChart {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiSapChart> for ::com_shim::VARIANT {
        fn variant_from(value: GuiSapChart) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiSapChart> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiSapChart::from(idisp))
        }
    }
    pub struct GuiScrollbar {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiScrollbar {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiScrollbarExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn maximum(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Maximum")?.variant_into()?,
            )
        }
        fn minimum(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Minimum")?.variant_into()?,
            )
        }
        fn page_size(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("PageSize")?.variant_into()?,
            )
        }
        fn position(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Position")?.variant_into()?,
            )
        }
        fn set_position(&self, value: i32) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("Position", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn range(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Range")?.variant_into()?)
        }
    }
    impl GuiScrollbarExt for GuiScrollbar {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiScrollbar {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiScrollbar> for ::com_shim::VARIANT {
        fn variant_from(value: GuiScrollbar) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiScrollbar> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiScrollbar::from(idisp))
        }
    }
    pub struct GuiScrollContainer {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiScrollContainer {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiScrollContainerExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn horizontal_scrollbar(&self) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("HorizontalScrollbar")?.variant_into()?,
            )
        }
        fn vertical_scrollbar(&self) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("VerticalScrollbar")?.variant_into()?,
            )
        }
    }
    impl GuiScrollContainerExt for GuiScrollContainer {}
    impl GuiVContainerExt for GuiScrollContainer {}
    impl GuiVComponentExt for GuiScrollContainer {}
    impl GuiContainerExt for GuiScrollContainer {}
    impl GuiComponentExt for GuiScrollContainer {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiScrollContainer {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiScrollContainer> for ::com_shim::VARIANT {
        fn variant_from(value: GuiScrollContainer) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiScrollContainer> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiScrollContainer::from(idisp))
        }
    }
    pub struct GuiSession {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiSession {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiSessionExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn acc_enhanced_tab_chain(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("AccEnhancedTabChain")?.variant_into()?,
            )
        }
        fn set_acc_enhanced_tab_chain(&self, value: bool) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("AccEnhancedTabChain", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn acc_symbol_replacement(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("AccSymbolReplacement")?.variant_into()?,
            )
        }
        fn set_acc_symbol_replacement(&self, value: bool) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("AccSymbolReplacement", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn active_window(&self) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ActiveWindow")?.variant_into()?,
            )
        }
        fn busy(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Busy")?.variant_into()?)
        }
        fn set_busy(&self, value: bool) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("Busy", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn info(&self) -> ::com_shim::Result<GuiSessionInfo> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Info")?.variant_into()?)
        }
        fn is_active(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsActive")?.variant_into()?,
            )
        }
        fn is_list_box_active(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsListBoxActive")?.variant_into()?,
            )
        }
        fn list_box_curr_entry(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ListBoxCurrEntry")?.variant_into()?,
            )
        }
        fn list_box_curr_entry_height(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ListBoxCurrEntryHeight")?.variant_into()?,
            )
        }
        fn list_box_curr_entry_left(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ListBoxCurrEntryLeft")?.variant_into()?,
            )
        }
        fn list_box_curr_entry_top(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ListBoxCurrEntryTop")?.variant_into()?,
            )
        }
        fn list_box_curr_entry_width(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ListBoxCurrEntryWidth")?.variant_into()?,
            )
        }
        fn list_box_height(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ListBoxHeight")?.variant_into()?,
            )
        }
        fn list_box_left(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ListBoxLeft")?.variant_into()?,
            )
        }
        fn list_box_top(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ListBoxTop")?.variant_into()?,
            )
        }
        fn list_box_width(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ListBoxWidth")?.variant_into()?,
            )
        }
        fn passport_pre_system_id(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("PassportPreSystemId")?.variant_into()?,
            )
        }
        fn set_passport_pre_system_id(&self, value: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("PassportPreSystemId", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn passport_system_id(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("PassportSystemId")?.variant_into()?,
            )
        }
        fn set_passport_system_id(&self, value: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("PassportSystemId", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn passport_transaction_id(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("PassportTransactionId")?.variant_into()?,
            )
        }
        fn set_passport_transaction_id(&self, value: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("PassportTransactionId", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn progress_percent(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ProgressPercent")?.variant_into()?,
            )
        }
        fn progress_text(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ProgressText")?.variant_into()?,
            )
        }
        fn record(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Record")?.variant_into()?,
            )
        }
        fn set_record(&self, value: bool) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("Record", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn record_file(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("RecordFile")?.variant_into()?,
            )
        }
        fn set_record_file(&self, value: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("RecordFile", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn save_as_unicode(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("SaveAsUnicode")?.variant_into()?,
            )
        }
        fn set_save_as_unicode(&self, value: bool) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("SaveAsUnicode", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn show_dropdown_keys(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ShowDropdownKeys")?.variant_into()?,
            )
        }
        fn set_show_dropdown_keys(&self, value: bool) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("ShowDropdownKeys", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn suppress_backend_popups(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("SuppressBackendPopups")?.variant_into()?,
            )
        }
        fn set_suppress_backend_popups(&self, value: bool) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("SuppressBackendPopups", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn test_tool_mode(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("TestToolMode")?.variant_into()?,
            )
        }
        fn set_test_tool_mode(&self, value: i32) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("TestToolMode", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn as_std_number_format(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "AsStdNumberFormat",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn clear_error_list(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("ClearErrorList", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn create_session(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("CreateSession", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn enable_jaws_events(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("EnableJawsEvents", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn end_transaction(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("EndTransaction", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn find_by_position(
            &self,
            p0: i32,
            p1: i32,
        ) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("FindByPosition", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_icon_resource_name(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetIconResourceName",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_object_tree(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetObjectTree",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_v_key_description(&self, p0: i32) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetVKeyDescription",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn lock_session_ui(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("LockSessionUI", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn send_command(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "SendCommand",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn send_command_async(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "SendCommandAsync",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn start_transaction(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "StartTransaction",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn unlock_session_ui(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("UnlockSessionUI", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiSessionExt for GuiSession {}
    impl GuiContainerExt for GuiSession {}
    impl GuiComponentExt for GuiSession {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiSession {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiSession> for ::com_shim::VARIANT {
        fn variant_from(value: GuiSession) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiSession> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiSession::from(idisp))
        }
    }
    pub struct GuiSessionInfo {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiSessionInfo {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiSessionInfoExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn application_server(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ApplicationServer")?.variant_into()?,
            )
        }
        fn client(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Client")?.variant_into()?,
            )
        }
        fn codepage(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Codepage")?.variant_into()?,
            )
        }
        fn flushes(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Flushes")?.variant_into()?,
            )
        }
        fn group(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Group")?.variant_into()?)
        }
        fn gui_codepage(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("GuiCodepage")?.variant_into()?,
            )
        }
        fn i18n_mode(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("I18NMode")?.variant_into()?,
            )
        }
        fn interpretation_time(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("InterpretationTime")?.variant_into()?,
            )
        }
        fn is_low_speed_connection(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsLowSpeedConnection")?.variant_into()?,
            )
        }
        fn language(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Language")?.variant_into()?,
            )
        }
        fn message_server(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("MessageServer")?.variant_into()?,
            )
        }
        fn program(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Program")?.variant_into()?,
            )
        }
        fn response_time(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ResponseTime")?.variant_into()?,
            )
        }
        fn round_trips(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("RoundTrips")?.variant_into()?,
            )
        }
        fn screen_number(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ScreenNumber")?.variant_into()?,
            )
        }
        fn scripting_mode_read_only(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ScriptingModeReadOnly")?.variant_into()?,
            )
        }
        fn scripting_mode_recording_disabled(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self
                    .get_idispatch()
                    .get("ScriptingModeRecordingDisabled")?
                    .variant_into()?,
            )
        }
        fn session_number(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("SessionNumber")?.variant_into()?,
            )
        }
        fn system_name(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("SystemName")?.variant_into()?,
            )
        }
        fn system_number(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("SystemNumber")?.variant_into()?,
            )
        }
        fn system_session_id(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("SystemSessionId")?.variant_into()?,
            )
        }
        fn transaction(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Transaction")?.variant_into()?,
            )
        }
        fn ui_guideline(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("UI_GUIDELINE")?.variant_into()?,
            )
        }
        fn user(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("User")?.variant_into()?)
        }
    }
    impl GuiSessionInfoExt for GuiSessionInfo {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiSessionInfo {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiSessionInfo> for ::com_shim::VARIANT {
        fn variant_from(value: GuiSessionInfo) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiSessionInfo> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiSessionInfo::from(idisp))
        }
    }
    pub struct GuiShell {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiShell {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiShellExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn acc_description(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("AccDescription")?.variant_into()?,
            )
        }
        fn drag_drop_supported(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("DragDropSupported")?.variant_into()?,
            )
        }
        fn handle(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Handle")?.variant_into()?,
            )
        }
        fn ocx_events(&self) -> ::com_shim::Result<GuiCollection> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("OcxEvents")?.variant_into()?,
            )
        }
        fn sub_type(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("SubType")?.variant_into()?,
            )
        }
        fn select_context_menu_item(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "SelectContextMenuItem",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn select_context_menu_item_by_position(
            &self,
            p0: String,
        ) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "SelectContextMenuItemByPosition",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn select_context_menu_item_by_text(
            &self,
            p0: String,
        ) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "SelectContextMenuItemByText",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiShellExt for GuiShell {}
    impl GuiVContainerExt for GuiShell {}
    impl GuiVComponentExt for GuiShell {}
    impl GuiContainerExt for GuiShell {}
    impl GuiComponentExt for GuiShell {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiShell {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiShell> for ::com_shim::VARIANT {
        fn variant_from(value: GuiShell) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiShell> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiShell::from(idisp))
        }
    }
    pub struct GuiSimpleContainer {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiSimpleContainer {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiSimpleContainerExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn is_list_element(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsListElement")?.variant_into()?,
            )
        }
        fn is_step_loop(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsStepLoop")?.variant_into()?,
            )
        }
        fn is_step_loop_in_table_structure(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsStepLoopInTableStructure")?.variant_into()?,
            )
        }
        fn loop_col_count(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("LoopColCount")?.variant_into()?,
            )
        }
        fn loop_current_col(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("LoopCurrentCol")?.variant_into()?,
            )
        }
        fn loop_current_col_count(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("LoopCurrentColCount")?.variant_into()?,
            )
        }
        fn loop_current_row(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("LoopCurrentRow")?.variant_into()?,
            )
        }
        fn loop_row_count(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("LoopRowCount")?.variant_into()?,
            )
        }
        fn get_list_property(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetListProperty",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_list_property_non_rec(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetListPropertyNonRec",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
    }
    impl GuiSimpleContainerExt for GuiSimpleContainer {}
    impl GuiVContainerExt for GuiSimpleContainer {}
    impl GuiVComponentExt for GuiSimpleContainer {}
    impl GuiContainerExt for GuiSimpleContainer {}
    impl GuiComponentExt for GuiSimpleContainer {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiSimpleContainer {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiSimpleContainer> for ::com_shim::VARIANT {
        fn variant_from(value: GuiSimpleContainer) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiSimpleContainer> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiSimpleContainer::from(idisp))
        }
    }
    pub struct GuiSplit {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiSplit {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiSplitExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn is_vertical(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsVertical")?.variant_into()?,
            )
        }
        fn get_col_size(&self, p0: i32) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetColSize",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_row_size(&self, p0: i32) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetRowSize",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn set_col_size(&self, p0: i32, p1: i32) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("SetColSize", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn set_row_size(&self, p0: i32, p1: i32) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("SetRowSize", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiSplitExt for GuiSplit {}
    impl GuiVContainerExt for GuiSplit {}
    impl GuiVComponentExt for GuiSplit {}
    impl GuiContainerExt for GuiSplit {}
    impl GuiComponentExt for GuiSplit {}
    impl GuiShellExt for GuiSplit {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiSplit {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiSplit> for ::com_shim::VARIANT {
        fn variant_from(value: GuiSplit) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiSplit> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiSplit::from(idisp))
        }
    }
    pub struct GuiSplitterContainer {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiSplitterContainer {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiSplitterContainerExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn is_vertical(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsVertical")?.variant_into()?,
            )
        }
        fn sash_position(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("SashPosition")?.variant_into()?,
            )
        }
        fn set_sash_position(&self, value: i32) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("SashPosition", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiSplitterContainerExt for GuiSplitterContainer {}
    impl GuiVContainerExt for GuiSplitterContainer {}
    impl GuiVComponentExt for GuiSplitterContainer {}
    impl GuiComponentExt for GuiSplitterContainer {}
    impl GuiContainerExt for GuiSplitterContainer {}
    impl GuiShellExt for GuiSplitterContainer {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiSplitterContainer {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiSplitterContainer> for ::com_shim::VARIANT {
        fn variant_from(value: GuiSplitterContainer) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiSplitterContainer> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiSplitterContainer::from(idisp))
        }
    }
    pub struct GuiStage {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiStage {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiStageExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn context_menu(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "ContextMenu",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn double_click(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "DoubleClick",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn select_items(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "SelectItems",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiStageExt for GuiStage {}
    impl GuiVComponentExt for GuiStage {}
    impl GuiVContainerExt for GuiStage {}
    impl GuiContainerExt for GuiStage {}
    impl GuiShellExt for GuiStage {}
    impl GuiComponentExt for GuiStage {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiStage {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiStage> for ::com_shim::VARIANT {
        fn variant_from(value: GuiStage) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiStage> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiStage::from(idisp))
        }
    }
    pub struct GuiStatusbar {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiStatusbar {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiStatusbarExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn handle(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Handle")?.variant_into()?,
            )
        }
        fn message_as_popup(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("MessageAsPopup")?.variant_into()?,
            )
        }
        fn message_has_long_text(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("MessageHasLongText")?.variant_into()?,
            )
        }
        fn message_id(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("MessageId")?.variant_into()?,
            )
        }
        fn message_number(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("MessageNumber")?.variant_into()?,
            )
        }
        fn message_parameter(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("MessageParameter")?.variant_into()?,
            )
        }
        fn message_type(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("MessageType")?.variant_into()?,
            )
        }
        fn create_support_message_click(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("CreateSupportMessageClick", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn double_click(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("DoubleClick", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn service_request_click(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("ServiceRequestClick", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiStatusbarExt for GuiStatusbar {}
    impl GuiVComponentExt for GuiStatusbar {}
    impl GuiVContainerExt for GuiStatusbar {}
    impl GuiComponentExt for GuiStatusbar {}
    impl GuiContainerExt for GuiStatusbar {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiStatusbar {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiStatusbar> for ::com_shim::VARIANT {
        fn variant_from(value: GuiStatusbar) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiStatusbar> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiStatusbar::from(idisp))
        }
    }
    pub struct GuiStatusBarLink {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiStatusBarLink {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiStatusBarLinkExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn press(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("Press", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiStatusBarLinkExt for GuiStatusBarLink {}
    impl GuiVComponentExt for GuiStatusBarLink {}
    impl GuiComponentExt for GuiStatusBarLink {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiStatusBarLink {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiStatusBarLink> for ::com_shim::VARIANT {
        fn variant_from(value: GuiStatusBarLink) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiStatusBarLink> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiStatusBarLink::from(idisp))
        }
    }
    pub struct GuiStatusPane {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiStatusPane {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiStatusPaneExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn children(&self) -> ::com_shim::Result<GuiComponentCollection> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Children")?.variant_into()?,
            )
        }
    }
    impl GuiStatusPaneExt for GuiStatusPane {}
    impl GuiVComponentExt for GuiStatusPane {}
    impl GuiComponentExt for GuiStatusPane {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiStatusPane {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiStatusPane> for ::com_shim::VARIANT {
        fn variant_from(value: GuiStatusPane) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiStatusPane> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiStatusPane::from(idisp))
        }
    }
    pub struct GuiTab {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiTab {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiTabExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn scroll_to_left(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("ScrollToLeft", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn select(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("Select", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiTabExt for GuiTab {}
    impl GuiVContainerExt for GuiTab {}
    impl GuiVComponentExt for GuiTab {}
    impl GuiContainerExt for GuiTab {}
    impl GuiComponentExt for GuiTab {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiTab {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiTab> for ::com_shim::VARIANT {
        fn variant_from(value: GuiTab) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiTab> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiTab::from(idisp))
        }
    }
    pub struct GuiTableColumn {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiTableColumn {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiTableColumnExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn default_tooltip(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("DefaultTooltip")?.variant_into()?,
            )
        }
        fn fixed(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Fixed")?.variant_into()?)
        }
        fn icon_name(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IconName")?.variant_into()?,
            )
        }
        fn selected(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Selected")?.variant_into()?,
            )
        }
        fn title(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Title")?.variant_into()?)
        }
        fn tooltip(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Tooltip")?.variant_into()?,
            )
        }
    }
    impl GuiTableColumnExt for GuiTableColumn {}
    impl GuiComponentCollectionExt for GuiTableColumn {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiTableColumn {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiTableColumn> for ::com_shim::VARIANT {
        fn variant_from(value: GuiTableColumn) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiTableColumn> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiTableColumn::from(idisp))
        }
    }
    pub struct GuiTableControl {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiTableControl {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiTableControlExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn char_height(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharHeight")?.variant_into()?,
            )
        }
        fn char_left(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharLeft")?.variant_into()?,
            )
        }
        fn char_top(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharTop")?.variant_into()?,
            )
        }
        fn char_width(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharWidth")?.variant_into()?,
            )
        }
        fn columns(&self) -> ::com_shim::Result<GuiCollection> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Columns")?.variant_into()?,
            )
        }
        fn current_col(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CurrentCol")?.variant_into()?,
            )
        }
        fn current_row(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CurrentRow")?.variant_into()?,
            )
        }
        fn horizontal_scrollbar(&self) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("HorizontalScrollbar")?.variant_into()?,
            )
        }
        fn row_count(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("RowCount")?.variant_into()?,
            )
        }
        fn rows(&self) -> ::com_shim::Result<GuiCollection> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Rows")?.variant_into()?)
        }
        fn table_field_name(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("TableFieldName")?.variant_into()?,
            )
        }
        fn vertical_scrollbar(&self) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("VerticalScrollbar")?.variant_into()?,
            )
        }
        fn visible_row_count(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("VisibleRowCount")?.variant_into()?,
            )
        }
        fn configure_layout(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("ConfigureLayout", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn deselect_all_columns(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("DeselectAllColumns", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn get_absolute_row(&self, p0: i32) -> ::com_shim::Result<GuiTableRow> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetAbsoluteRow",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_cell(&self, p0: i32, p1: i32) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetCell", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn reorder_table(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "ReorderTable",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn select_all_columns(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("SelectAllColumns", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiTableControlExt for GuiTableControl {}
    impl GuiVContainerExt for GuiTableControl {}
    impl GuiVComponentExt for GuiTableControl {}
    impl GuiContainerExt for GuiTableControl {}
    impl GuiComponentExt for GuiTableControl {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiTableControl {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiTableControl> for ::com_shim::VARIANT {
        fn variant_from(value: GuiTableControl) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiTableControl> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiTableControl::from(idisp))
        }
    }
    pub struct GuiTableRow {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiTableRow {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiTableRowExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn selectable(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Selectable")?.variant_into()?,
            )
        }
        fn selected(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Selected")?.variant_into()?,
            )
        }
        fn set_selected(&self, value: bool) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("Selected", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiTableRowExt for GuiTableRow {}
    impl GuiComponentCollectionExt for GuiTableRow {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiTableRow {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiTableRow> for ::com_shim::VARIANT {
        fn variant_from(value: GuiTableRow) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiTableRow> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiTableRow::from(idisp))
        }
    }
    pub struct GuiTabStrip {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiTabStrip {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiTabStripExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn char_height(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharHeight")?.variant_into()?,
            )
        }
        fn char_left(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharLeft")?.variant_into()?,
            )
        }
        fn char_top(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharTop")?.variant_into()?,
            )
        }
        fn char_width(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CharWidth")?.variant_into()?,
            )
        }
        fn left_tab(&self) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("LeftTab")?.variant_into()?,
            )
        }
        fn selected_tab(&self) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("SelectedTab")?.variant_into()?,
            )
        }
    }
    impl GuiTabStripExt for GuiTabStrip {}
    impl GuiVContainerExt for GuiTabStrip {}
    impl GuiVComponentExt for GuiTabStrip {}
    impl GuiContainerExt for GuiTabStrip {}
    impl GuiComponentExt for GuiTabStrip {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiTabStrip {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiTabStrip> for ::com_shim::VARIANT {
        fn variant_from(value: GuiTabStrip) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiTabStrip> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiTabStrip::from(idisp))
        }
    }
    pub struct GuiTextedit {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiTextedit {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiTexteditExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn current_column(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CurrentColumn")?.variant_into()?,
            )
        }
        fn current_line(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CurrentLine")?.variant_into()?,
            )
        }
        fn first_visible_line(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("FirstVisibleLine")?.variant_into()?,
            )
        }
        fn set_first_visible_line(&self, value: i32) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("FirstVisibleLine", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn last_visible_line(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("LastVisibleLine")?.variant_into()?,
            )
        }
        fn line_count(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("LineCount")?.variant_into()?,
            )
        }
        fn number_of_unprotected_text_parts(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("NumberOfUnprotectedTextParts")?.variant_into()?,
            )
        }
        fn selected_text(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("SelectedText")?.variant_into()?,
            )
        }
        fn selection_end_column(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("SelectionEndColumn")?.variant_into()?,
            )
        }
        fn selection_end_line(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("SelectionEndLine")?.variant_into()?,
            )
        }
        fn selection_index_end(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("SelectionIndexEnd")?.variant_into()?,
            )
        }
        fn selection_index_start(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("SelectionIndexStart")?.variant_into()?,
            )
        }
        fn selection_start_column(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("SelectionStartColumn")?.variant_into()?,
            )
        }
        fn selection_start_line(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("SelectionStartLine")?.variant_into()?,
            )
        }
        fn context_menu(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("ContextMenu", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn double_click(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("DoubleClick", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn get_line_text(&self, p0: i32) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetLineText",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_unprotected_text_part(&self, p0: i32) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetUnprotectedTextPart",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn is_breakpoint_line(&self, p0: i32) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "IsBreakpointLine",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn is_comment_line(&self, p0: i32) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "IsCommentLine",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn is_highlighted_line(&self, p0: i32) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "IsHighlightedLine",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn is_protected_line(&self, p0: i32) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "IsProtectedLine",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn is_selected_line(&self, p0: i32) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "IsSelectedLine",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn modified_status_changed(&self, p0: bool) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "ModifiedStatusChanged",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn multiple_files_dropped(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("MultipleFilesDropped", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn press_f1(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("PressF1", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn press_f4(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("PressF4", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn set_selection_indexes(&self, p0: i32, p1: i32) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("SetSelectionIndexes", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn set_unprotected_text_part(
            &self,
            p0: i32,
            p1: String,
        ) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("SetUnprotectedTextPart", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn single_file_dropped(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "SingleFileDropped",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiTexteditExt for GuiTextedit {}
    impl GuiShellExt for GuiTextedit {}
    impl GuiVComponentExt for GuiTextedit {}
    impl GuiVContainerExt for GuiTextedit {}
    impl GuiContainerExt for GuiTextedit {}
    impl GuiComponentExt for GuiTextedit {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiTextedit {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiTextedit> for ::com_shim::VARIANT {
        fn variant_from(value: GuiTextedit) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiTextedit> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiTextedit::from(idisp))
        }
    }
    pub struct GuiTextField {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiTextField {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiTextFieldExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn caret_position(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("CaretPosition")?.variant_into()?,
            )
        }
        fn set_caret_position(&self, value: i32) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("CaretPosition", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn displayed_text(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("DisplayedText")?.variant_into()?,
            )
        }
        fn highlighted(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Highlighted")?.variant_into()?,
            )
        }
        fn history_cur_entry(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("HistoryCurEntry")?.variant_into()?,
            )
        }
        fn history_cur_index(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("HistoryCurIndex")?.variant_into()?,
            )
        }
        fn history_is_active(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("HistoryIsActive")?.variant_into()?,
            )
        }
        fn history_list(&self) -> ::com_shim::Result<GuiCollection> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("HistoryList")?.variant_into()?,
            )
        }
        fn is_hotspot(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsHotspot")?.variant_into()?,
            )
        }
        fn is_left_label(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsLeftLabel")?.variant_into()?,
            )
        }
        fn is_list_element(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsListElement")?.variant_into()?,
            )
        }
        fn is_o_field(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsOField")?.variant_into()?,
            )
        }
        fn is_right_label(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsRightLabel")?.variant_into()?,
            )
        }
        fn left_label(&self) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("LeftLabel")?.variant_into()?,
            )
        }
        fn max_length(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("MaxLength")?.variant_into()?,
            )
        }
        fn numerical(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Numerical")?.variant_into()?,
            )
        }
        fn required(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Required")?.variant_into()?,
            )
        }
        fn right_label(&self) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("RightLabel")?.variant_into()?,
            )
        }
        fn get_list_property(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetListProperty",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_list_property_non_rec(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetListPropertyNonRec",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
    }
    impl GuiTextFieldExt for GuiTextField {}
    impl GuiVComponentExt for GuiTextField {}
    impl GuiComponentExt for GuiTextField {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiTextField {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiTextField> for ::com_shim::VARIANT {
        fn variant_from(value: GuiTextField) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiTextField> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiTextField::from(idisp))
        }
    }
    pub struct GuiTitlebar {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiTitlebar {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiTitlebarExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {}
    impl GuiTitlebarExt for GuiTitlebar {}
    impl GuiVComponentExt for GuiTitlebar {}
    impl GuiVContainerExt for GuiTitlebar {}
    impl GuiContainerExt for GuiTitlebar {}
    impl GuiComponentExt for GuiTitlebar {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiTitlebar {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiTitlebar> for ::com_shim::VARIANT {
        fn variant_from(value: GuiTitlebar) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiTitlebar> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiTitlebar::from(idisp))
        }
    }
    pub struct GuiToolbar {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiToolbar {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiToolbarExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {}
    impl GuiToolbarExt for GuiToolbar {}
    impl GuiVComponentExt for GuiToolbar {}
    impl GuiVContainerExt for GuiToolbar {}
    impl GuiContainerExt for GuiToolbar {}
    impl GuiComponentExt for GuiToolbar {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiToolbar {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiToolbar> for ::com_shim::VARIANT {
        fn variant_from(value: GuiToolbar) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiToolbar> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiToolbar::from(idisp))
        }
    }
    pub struct GuiToolbarControl {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiToolbarControl {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiToolbarControlExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn button_count(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ButtonCount")?.variant_into()?,
            )
        }
        fn focused_button(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("FocusedButton")?.variant_into()?,
            )
        }
        fn get_button_checked(&self, p0: i32) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetButtonChecked",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_button_enabled(&self, p0: i32) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetButtonEnabled",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_button_icon(&self, p0: i32) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetButtonIcon",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_button_id(&self, p0: i32) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetButtonId",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_button_text(&self, p0: i32) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetButtonText",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_button_tooltip(&self, p0: i32) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetButtonTooltip",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_button_type(&self, p0: i32) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetButtonType",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_menu_item_id_from_position(&self, p0: i32) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetMenuItemIdFromPosition",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn press_button(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "PressButton",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn press_context_button(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "PressContextButton",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn select_menu_item(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "SelectMenuItem",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn select_menu_item_by_text(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "SelectMenuItemByText",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiToolbarControlExt for GuiToolbarControl {}
    impl GuiShellExt for GuiToolbarControl {}
    impl GuiVComponentExt for GuiToolbarControl {}
    impl GuiVContainerExt for GuiToolbarControl {}
    impl GuiComponentExt for GuiToolbarControl {}
    impl GuiContainerExt for GuiToolbarControl {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiToolbarControl {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiToolbarControl> for ::com_shim::VARIANT {
        fn variant_from(value: GuiToolbarControl) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiToolbarControl> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiToolbarControl::from(idisp))
        }
    }
    pub struct GuiTree {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiTree {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiTreeExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn hierarchy_header_width(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("HierarchyHeaderWidth")?.variant_into()?,
            )
        }
        fn selected_node(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("SelectedNode")?.variant_into()?,
            )
        }
        fn top_node(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("TopNode")?.variant_into()?,
            )
        }
        fn change_checkbox(
            &self,
            p0: String,
            p1: String,
            p2: bool,
        ) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("ChangeCheckbox", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn click_link(&self, p0: String, p1: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("ClickLink", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn collapse_node(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "CollapseNode",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn default_context_menu(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("DefaultContextMenu", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn double_click_item(&self, p0: String, p1: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("DoubleClickItem", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn double_click_node(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "DoubleClickNode",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn ensure_visible_horizontal_item(
            &self,
            p0: String,
            p1: String,
        ) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("EnsureVisibleHorizontalItem", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn expand_node(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "ExpandNode",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn find_node_key_by_path(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "FindNodeKeyByPath",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_abap_image(&self, p0: String, p1: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetAbapImage", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_check_box_state(
            &self,
            p0: String,
            p1: String,
        ) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetCheckBoxState", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_column_index_from_name(&self, p0: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetColumnIndexFromName",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_column_title_from_name(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetColumnTitleFromName",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_focused_node_key(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("GetFocusedNodeKey", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_hierarchy_level(&self, p0: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetHierarchyLevel",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_hierarchy_title(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("GetHierarchyTitle", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_is_disabled(&self, p0: String, p1: String) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetIsDisabled", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_is_editable(&self, p0: String, p1: String) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetIsEditable", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_is_high_lighted(
            &self,
            p0: String,
            p1: String,
        ) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetIsHighLighted", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_item_height(&self, p0: String, p1: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetItemHeight", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_item_left(&self, p0: String, p1: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetItemLeft", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_item_style(&self, p0: String, p1: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetItemStyle", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_item_text(&self, p0: String, p1: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetItemText", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_item_text_color(
            &self,
            p0: String,
            p1: String,
        ) -> ::com_shim::Result<u64> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetItemTextColor", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_item_tool_tip(
            &self,
            p0: String,
            p1: String,
        ) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetItemToolTip", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_item_top(&self, p0: String, p1: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetItemTop", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_item_type(&self, p0: String, p1: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetItemType", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_item_width(&self, p0: String, p1: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetItemWidth", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_list_tree_node_item_count(&self, p0: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetListTreeNodeItemCount",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_next_node_key(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetNextNodeKey",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_node_abap_image(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetNodeAbapImage",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_node_children_count(&self, p0: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetNodeChildrenCount",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_node_children_count_by_path(
            &self,
            p0: String,
        ) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetNodeChildrenCountByPath",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_node_height(&self, p0: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetNodeHeight",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_node_index(&self, p0: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetNodeIndex",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_node_key_by_path(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetNodeKeyByPath",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_node_left(&self, p0: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetNodeLeft",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_node_path_by_key(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetNodePathByKey",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_node_style(&self, p0: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetNodeStyle",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_node_text_by_key(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetNodeTextByKey",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_node_text_by_path(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetNodeTextByPath",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_node_text_color(&self, p0: String) -> ::com_shim::Result<u64> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetNodeTextColor",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_node_tool_tip(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetNodeToolTip",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_node_top(&self, p0: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetNodeTop",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_node_width(&self, p0: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetNodeWidth",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_parent(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetParent",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_previous_node_key(&self, p0: String) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetPreviousNodeKey",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_selection_mode(&self) -> ::com_shim::Result<i16> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("GetSelectionMode", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_style_description(&self, p0: i32) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "GetStyleDescription",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn get_tree_type(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("GetTreeType", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn header_context_menu(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "HeaderContextMenu",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn is_folder(&self, p0: String) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "IsFolder",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn is_folder_expandable(&self, p0: String) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "IsFolderExpandable",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn is_folder_expanded(&self, p0: String) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "IsFolderExpanded",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn item_context_menu(&self, p0: String, p1: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("ItemContextMenu", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn node_context_menu(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "NodeContextMenu",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn press_button(&self, p0: String, p1: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("PressButton", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn press_header(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "PressHeader",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn press_key(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "PressKey",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn select_column(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "SelectColumn",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn selected_item_column(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("SelectedItemColumn", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn selected_item_node(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call("SelectedItemNode", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn select_item(&self, p0: String, p1: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("SelectItem", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn select_node(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "SelectNode",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn set_check_box_state(
            &self,
            p0: String,
            p1: String,
            p2: i32,
        ) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("SetCheckBoxState", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn set_column_width(&self, p0: String, p1: i32) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("SetColumnWidth", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn unselect_all(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("UnselectAll", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn unselect_column(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "UnselectColumn",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn unselect_node(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "UnselectNode",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiTreeExt for GuiTree {}
    impl GuiShellExt for GuiTree {}
    impl GuiVContainerExt for GuiTree {}
    impl GuiVComponentExt for GuiTree {}
    impl GuiComponentExt for GuiTree {}
    impl GuiContainerExt for GuiTree {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiTree {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiTree> for ::com_shim::VARIANT {
        fn variant_from(value: GuiTree) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiTree> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiTree::from(idisp))
        }
    }
    pub struct GuiUserArea {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiUserArea {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiUserAreaExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn horizontal_scrollbar(&self) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("HorizontalScrollbar")?.variant_into()?,
            )
        }
        fn is_otf_preview(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsOTFPreview")?.variant_into()?,
            )
        }
        fn vertical_scrollbar(&self) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("VerticalScrollbar")?.variant_into()?,
            )
        }
        fn find_by_label(
            &self,
            p0: String,
            p1: String,
        ) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("FindByLabel", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn list_navigate(&self, p0: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "ListNavigate",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiUserAreaExt for GuiUserArea {}
    impl GuiVContainerExt for GuiUserArea {}
    impl GuiVComponentExt for GuiUserArea {}
    impl GuiComponentExt for GuiUserArea {}
    impl GuiContainerExt for GuiUserArea {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiUserArea {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiUserArea> for ::com_shim::VARIANT {
        fn variant_from(value: GuiUserArea) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiUserArea> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiUserArea::from(idisp))
        }
    }
    pub struct GuiUtils {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiUtils {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiUtilsExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn message_option_ok(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("MESSAGE_OPTION_OK")?.variant_into()?,
            )
        }
        fn message_option_okcancel(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("MESSAGE_OPTION_OKCANCEL")?.variant_into()?,
            )
        }
        fn message_option_yesno(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("MESSAGE_OPTION_YESNO")?.variant_into()?,
            )
        }
        fn message_result_cancel(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("MESSAGE_RESULT_CANCEL")?.variant_into()?,
            )
        }
        fn message_result_no(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("MESSAGE_RESULT_NO")?.variant_into()?,
            )
        }
        fn message_result_ok(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("MESSAGE_RESULT_OK")?.variant_into()?,
            )
        }
        fn message_result_yes(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("MESSAGE_RESULT_YES")?.variant_into()?,
            )
        }
        fn message_type_error(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("MESSAGE_TYPE_ERROR")?.variant_into()?,
            )
        }
        fn message_type_information(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("MESSAGE_TYPE_INFORMATION")?.variant_into()?,
            )
        }
        fn message_type_plain(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("MESSAGE_TYPE_PLAIN")?.variant_into()?,
            )
        }
        fn message_type_question(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("MESSAGE_TYPE_QUESTION")?.variant_into()?,
            )
        }
        fn message_type_warning(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("MESSAGE_TYPE_WARNING")?.variant_into()?,
            )
        }
        fn close_file(&self, p0: i32) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "CloseFile",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(())
        }
        fn open_file(&self, p0: String) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "OpenFile",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn show_message_box(
            &self,
            p0: String,
            p1: String,
            p2: i32,
            p3: i32,
        ) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("ShowMessageBox", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn write(&self, p0: i32, p1: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("Write", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
        fn write_line(&self, p0: i32, p1: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("WriteLine", (/*ERROR*/))?;
            ::std::result::Result::Ok(())
        }
    }
    impl GuiUtilsExt for GuiUtils {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiUtils {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiUtils> for ::com_shim::VARIANT {
        fn variant_from(value: GuiUtils) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiUtils> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiUtils::from(idisp))
        }
    }
    pub struct GuiVComponent {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiVComponent {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiVComponentExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn acc_label_collection(&self) -> ::com_shim::Result<GuiComponentCollection> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("AccLabelCollection")?.variant_into()?,
            )
        }
        fn acc_text(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("AccText")?.variant_into()?,
            )
        }
        fn acc_text_on_request(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("AccTextOnRequest")?.variant_into()?,
            )
        }
        fn acc_tooltip(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("AccTooltip")?.variant_into()?,
            )
        }
        fn changeable(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Changeable")?.variant_into()?,
            )
        }
        fn default_tooltip(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("DefaultTooltip")?.variant_into()?,
            )
        }
        fn height(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Height")?.variant_into()?,
            )
        }
        fn icon_name(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IconName")?.variant_into()?,
            )
        }
        fn is_symbol_font(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("IsSymbolFont")?.variant_into()?,
            )
        }
        fn left(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Left")?.variant_into()?)
        }
        fn modified(&self) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Modified")?.variant_into()?,
            )
        }
        fn parent_frame(&self) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ParentFrame")?.variant_into()?,
            )
        }
        fn screen_left(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ScreenLeft")?.variant_into()?,
            )
        }
        fn screen_top(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("ScreenTop")?.variant_into()?,
            )
        }
        fn text(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Text")?.variant_into()?)
        }
        fn set_text(&self, value: String) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let _ = self
                .get_idispatch()
                .set("Text", ::com_shim::VARIANT::variant_from(value))?;
            ::std::result::Result::Ok(())
        }
        fn tooltip(&self) -> ::com_shim::Result<String> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(
                self.get_idispatch().get("Tooltip")?.variant_into()?,
            )
        }
        fn top(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Top")?.variant_into()?)
        }
        fn width(&self) -> ::com_shim::Result<i32> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            ::std::result::Result::Ok(self.get_idispatch().get("Width")?.variant_into()?)
        }
        fn dump_state(&self, p0: String) -> ::com_shim::Result<GuiCollection> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "DumpState",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn set_focus(&self) -> ::com_shim::Result<()> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("SetFocus", ::alloc::vec::Vec::new())?;
            ::std::result::Result::Ok(())
        }
        fn visualize(&self, p0: bool) -> ::com_shim::Result<bool> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self
                .get_idispatch()
                .call(
                    "Visualize",
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([::com_shim::VARIANT::variant_from(p0)]),
                    ),
                )?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
    }
    impl GuiVComponentExt for GuiVComponent {}
    impl GuiComponentExt for GuiVComponent {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiVComponent {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiVComponent> for ::com_shim::VARIANT {
        fn variant_from(value: GuiVComponent) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiVComponent> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiVComponent::from(idisp))
        }
    }
    pub struct GuiVContainer {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiVContainer {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiVContainerExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {
        fn find_all_by_name(
            &self,
            p0: String,
            p1: String,
        ) -> ::com_shim::Result<GuiComponentCollection> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("FindAllByName", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn find_all_by_name_ex(
            &self,
            p0: String,
            p1: i32,
        ) -> ::com_shim::Result<GuiComponentCollection> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("FindAllByNameEx", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn find_by_name(
            &self,
            p0: String,
            p1: String,
        ) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("FindByName", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
        fn find_by_name_ex(
            &self,
            p0: String,
            p1: String,
        ) -> ::com_shim::Result<GuiComponent> {
            use ::com_shim::{IDispatchExt, VariantTypeExt};
            let r = self.get_idispatch().call("FindByNameEx", (/*ERROR*/))?;
            ::std::result::Result::Ok(r.variant_into()?)
        }
    }
    impl GuiVContainerExt for GuiVContainer {}
    impl GuiVComponentExt for GuiVContainer {}
    impl GuiComponentExt for GuiVContainer {}
    impl GuiContainerExt for GuiVContainer {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiVContainer {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiVContainer> for ::com_shim::VARIANT {
        fn variant_from(value: GuiVContainer) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiVContainer> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiVContainer::from(idisp))
        }
    }
    pub struct GuiVHViewSwitch {
        inner: ::com_shim::IDispatch,
    }
    impl ::com_shim::HasIDispatch for GuiVHViewSwitch {
        fn get_idispatch(&self) -> &::com_shim::IDispatch {
            &self.inner
        }
    }
    pub trait GuiVHViewSwitchExt<
        T: ::com_shim::HasIDispatch = Self,
    >: ::com_shim::HasIDispatch<T> {}
    impl GuiVHViewSwitchExt for GuiVHViewSwitch {}
    impl GuiVComponentExt for GuiVHViewSwitch {}
    impl GuiComponentExt for GuiVHViewSwitch {}
    impl ::std::convert::From<::com_shim::IDispatch> for GuiVHViewSwitch {
        fn from(value: ::com_shim::IDispatch) -> Self {
            Self { inner: value }
        }
    }
    impl ::com_shim::VariantTypeExt<'_, GuiVHViewSwitch> for ::com_shim::VARIANT {
        fn variant_from(value: GuiVHViewSwitch) -> ::com_shim::VARIANT {
            let idisp = &value.inner;
            ::com_shim::VARIANT::variant_from(idisp)
        }
        fn variant_into(&'_ self) -> ::com_shim::Result<GuiVHViewSwitch> {
            let idisp = <::com_shim::VARIANT as ::com_shim::VariantTypeExt<
                '_,
                &::com_shim::IDispatch,
            >>::variant_into(self)?
                .clone();
            ::std::result::Result::Ok(GuiVHViewSwitch::from(idisp))
        }
    }
}
pub use types::*;
/// A result of a call.
pub type Result<T> = ::windows::core::Result<T>;
/// An instance of a COM session. This should be kept whilst a connection to SAP is used.
pub struct SAPComInstance;
impl SAPComInstance {
    /// Initialise the COM environment.
    pub fn new() -> Result<Self> {
        {
            let lvl = ::log::Level::Debug;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api::log(
                    format_args!("CoInitialize\'ing."),
                    lvl,
                    &("sap_scripting", "sap_scripting", "src/lib.rs"),
                    21u32,
                    ::log::__private_api::Option::None,
                );
            }
        };
        unsafe {
            CoInitialize(None)?;
        }
        Ok(SAPComInstance)
    }
    /// Create an instance of the SAP wrapper
    pub fn sap_wrapper(&self) -> Result<SAPWrapper> {
        {
            let lvl = ::log::Level::Debug;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api::log(
                    format_args!("New CSapROTWrapper object generating."),
                    lvl,
                    &("sap_scripting", "sap_scripting", "src/lib.rs"),
                    30u32,
                    ::log::__private_api::Option::None,
                );
            }
        };
        SAPWrapper::new()
    }
}
impl Drop for SAPComInstance {
    fn drop(&mut self) {
        unsafe {
            CoUninitialize();
        }
    }
}
